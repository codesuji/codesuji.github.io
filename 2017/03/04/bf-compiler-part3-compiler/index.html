<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>BF Compiler Part 3 - Compiler | codesuji</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This is the third installment in creating a brainfuck (BF) compiler using F# and FParsec.  Previous posts discussed the parsing and the IL generation.  Now it it time to pull it all together into some">
<meta name="keywords" content="F#,FSharp,Compiler,MSIL,FParsec,Parsing">
<meta property="og:type" content="article">
<meta property="og:title" content="BF Compiler Part 3 - Compiler">
<meta property="og:url" content="http://codesuji.com/2017/03/04/bf-compiler-part3-compiler/index.html">
<meta property="og:site_name" content="codesuji">
<meta property="og:description" content="This is the third installment in creating a brainfuck (BF) compiler using F# and FParsec.  Previous posts discussed the parsing and the IL generation.  Now it it time to pull it all together into some">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://codesuji.com/images/bf1/helloworld_execute.png">
<meta property="og:updated_time" content="2020-05-11T00:35:47.482Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BF Compiler Part 3 - Compiler">
<meta name="twitter:description" content="This is the third installment in creating a brainfuck (BF) compiler using F# and FParsec.  Previous posts discussed the parsing and the IL generation.  Now it it time to pull it all together into some">
<meta name="twitter:image" content="http://codesuji.com/images/bf1/helloworld_execute.png">
  
    <link rel="alternate" href="/atom.xml" title="codesuji" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89982547-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">codesuji</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://codesuji.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-bf-compiler-part3-compiler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/04/bf-compiler-part3-compiler/" class="article-date">
  <time datetime="2017-03-05T01:04:45.000Z" itemprop="datePublished">2017-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      BF Compiler Part 3 - Compiler
    </h1>
  

 		<span class="post-count">Read Time: 18 minutes</span>
 	  </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is the third installment in creating a brainfuck (BF) compiler using <a href="http://fsharp.org/" target="_blank" rel="noopener">F#</a> and <a href="http://www.quanttec.com/fparsec/" target="_blank" rel="noopener">FParsec</a>.  Previous posts discussed the parsing and the IL generation.  Now it it time to pull it all together into something useful.  </p>
<a id="more"></a>
<p><strong>Series:</strong><br><a href="/2017/02/19/bf-compiler-part1-parsing">Part 1 (Parsing)</a><br><a href="/2017/02/26/bf-compiler-part2-msil">Part 2 (IL Generation)</a><br>Part 3 (Compiler)<br><a href="/2017/03/13/bf-compiler-part4-optimization">Part 4 (Optimization)</a></p>
<p>Using <a href="https://github.com/fsprojects/Paket" target="_blank" rel="noopener">Paket</a>, here is a sample paket.dependencies file.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source https:<span class="comment">//nuget.org/api/v2</span></span><br><span class="line"></span><br><span class="line">nuget FParsec </span><br></pre></td></tr></table></figure>
<p>Here is the standard boilerplate for loading assemblies and generally getting ready to go.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.IO.Directory.SetCurrentDirectory(__SOURCE_DIRECTORY__)</span><br><span class="line">#r <span class="string">"../packages/FParsec/lib/net40-client/FParsecCS.dll"</span></span><br><span class="line">#r <span class="string">"../packages/FParsec/lib/net40-client/FParsec.dll"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> System</span><br><span class="line"><span class="keyword">open</span> System.IO</span><br><span class="line"><span class="keyword">open</span> System.Runtime</span><br><span class="line"><span class="keyword">open</span> System.Reflection</span><br><span class="line"><span class="keyword">open</span> System.Reflection.Emit</span><br><span class="line"><span class="keyword">open</span> System.Text.RegularExpressions</span><br><span class="line"><span class="keyword">open</span> FParsec</span><br></pre></td></tr></table></figure>
<p>I’ll start with the parsing code.  I include it here for completeness sake, but there isn’t much new here.  From a logic perspective, I added <em>Comment</em> support into the parser (basically any char that isn’t a valid character).  I also wrapped the parsing code in a module for organizational purposes.  </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Language operators (used in parsing and emitting)</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ActionOps</span> </span>= Gt | Lt | Plus | Minus | Read | Write</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">AllOps</span> </span>= </span><br><span class="line">    | Op <span class="keyword">of</span> ActionOps </span><br><span class="line">    | Loop <span class="keyword">of</span> AllOps list</span><br><span class="line">    | Program <span class="keyword">of</span> AllOps list</span><br><span class="line">    | Comment</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////</span></span><br><span class="line"><span class="comment">// Parsing code</span></span><br><span class="line"><span class="keyword">module</span> Parser = </span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">UserState</span> </span>= unit</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Parser</span>&lt;<span class="title">'t</span>&gt; </span>= Parser&lt;<span class="symbol">'t</span>, UserState&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pGreater:Parser&lt;_&gt; = </span><br><span class="line">        pchar '&gt;' |&gt;&gt; <span class="keyword">fun</span> _ -&gt; Op Gt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pLesser:Parser&lt;_&gt; = </span><br><span class="line">        pchar '&lt;' |&gt;&gt; <span class="keyword">fun</span> _ -&gt; Op Lt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pPlus:Parser&lt;_&gt; = </span><br><span class="line">        pchar '+' |&gt;&gt; <span class="keyword">fun</span> _ -&gt; Op Plus</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pMinus:Parser&lt;_&gt; = </span><br><span class="line">        pchar '-' |&gt;&gt; <span class="keyword">fun</span> _ -&gt; Op Minus</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pPeriod:Parser&lt;_&gt; = </span><br><span class="line">        pchar '.' |&gt;&gt; <span class="keyword">fun</span> _ -&gt; Op Write</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> pComma:Parser&lt;_&gt; = </span><br><span class="line">        pchar ',' |&gt;&gt; <span class="keyword">fun</span> _ -&gt; Op Read</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pLBracket:Parser&lt;_&gt; = </span><br><span class="line">        pchar '[' |&gt;&gt; ignore </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pRBracket:Parser&lt;_&gt; = </span><br><span class="line">        pchar ']' |&gt;&gt; ignore</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pCommands = pGreater &lt;|&gt; pLesser &lt;|&gt; pPlus &lt;|&gt; pMinus &lt;|&gt; pPeriod &lt;|&gt; pComma </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (pLoop:Parser&lt;AllOps&gt;), (pLoopImpl:Parser&lt;AllOps&gt; ref) = createParserForwardedToRef()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> pLoopImpl := pLBracket &gt;&gt;. (many (pCommands &lt;|&gt; pLoop)) .&gt;&gt; pRBracket |&gt;&gt; <span class="keyword">fun</span> x -&gt; </span><br><span class="line">        Loop x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> commentChar c =</span><br><span class="line">        c &lt;&gt; '&gt;' &amp;&amp; </span><br><span class="line">        c &lt;&gt; '&lt;' &amp;&amp; </span><br><span class="line">        c &lt;&gt; '+' &amp;&amp; </span><br><span class="line">        c &lt;&gt; '-' &amp;&amp; </span><br><span class="line">        c &lt;&gt; '[' &amp;&amp; </span><br><span class="line">        c &lt;&gt; ']' &amp;&amp; </span><br><span class="line">        c &lt;&gt; '.' &amp;&amp; </span><br><span class="line">        c &lt;&gt; ','</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pComment:Parser&lt;_&gt; =         </span><br><span class="line">        many1Satisfy commentChar |&gt;&gt; <span class="keyword">fun</span> _ -&gt; Comment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build ast from source code</span></span><br><span class="line">    <span class="keyword">let</span> buildAst code = </span><br><span class="line">        run (many (pCommands &lt;|&gt; pLoop &lt;|&gt; pComment)) code </span><br></pre></td></tr></table></figure>
<p>This is the start of the new IL emitting code.  Sticking with the standard definition, the memory array will be of size 30,000.  <code>LocalBuilder</code> is an IL local variable object.  To protect me from myself, I leverage F# types to ensure that I’m using the correct variable in the correct place.  For those not familar with F#, this will become more obvious where the variables are used.  Simply, the type safety this brings is immensely useful and offers me a piece of mind.  As a sidenote, BF defines the use of a program counter.  I don’t actually need a program counter to keep track of where I am, so it’s excluded from my implementation.  It’s here, but commented out primarily for reference-sake.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Emitter = </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Size of memory (data[])</span></span><br><span class="line">    <span class="keyword">let</span> memorySize = <span class="number">30000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// IL Variable types</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">MemArray</span> </span>= MEM <span class="keyword">of</span> LocalBuilder</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">DpPointer</span> </span>= DP <span class="keyword">of</span> LocalBuilder</span><br><span class="line">    <span class="comment">//type PcPointer = PC of LocalBuilder</span></span><br></pre></td></tr></table></figure>
<p>There will some variable creation along the way.  To be consistent I create some functions to consistently implement that process. <em>ilGenerator</em> is basically the function the code is attached to.  Creating a scalar is straight forward.  Creating an array is a bit more involved.  I need to create the variable, then call <code>Newarr</code> with the element type and array size to initialize the array.  Once complete, I return the created variable</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create IL local variable</span></span><br><span class="line"><span class="keyword">let</span> createLocal (ilGenerator:ILGenerator) (t:Type) =</span><br><span class="line">    ilGenerator.DeclareLocal(t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create IL local array variable</span></span><br><span class="line"><span class="keyword">let</span> createLocalArray (ilGenerator:ILGenerator) (t:Type) (size:int) =</span><br><span class="line">    <span class="keyword">let</span> regex = <span class="keyword">new</span> Regex(<span class="string">@"\[\]$"</span>)</span><br><span class="line">    <span class="keyword">let</span> tElement = Type.GetType(regex.Replace(t.FullName, <span class="string">""</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> var = createLocal ilGenerator t</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldc_I4, size)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Newarr, tElement)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Stloc, var)</span><br><span class="line">    var</span><br></pre></td></tr></table></figure>
<p>Both the add and sub perform similar actions, add a value to a local variable.  As a quick refresher, there will be lots of pushing onto the stack, performing actions, and popping results off a stack.  As a result, these functions follow a pattern that will show up repeatably in this post.  <code>LdLoc</code> pushes a local variable value onto the stack. <code>Ldc_I4</code> pushes a 32bit int onto the stack; in this case the amount to be added/subtracted to/from the local variable value.  <code>Add</code> and <code>Sub</code> pop the top 2 values off the top of the stack, perform their respective actions, and push the result onto the stack.  <code>StLoc</code> pops a value off the stack and stores it in the local variable.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add int to IL local variable</span></span><br><span class="line"><span class="keyword">let</span> addLocalInt (ilGenerator:ILGenerator) (var:LocalBuilder) (i:int) =</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, var)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldc_I4, i)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Add)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Stloc, var)</span><br><span class="line"></span><br><span class="line"><span class="comment">// subtract int from IL local variable</span></span><br><span class="line"><span class="keyword">let</span> subLocalInt (ilGenerator:ILGenerator) (var:LocalBuilder) (i:int) =</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, var)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldc_I4, i)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Sub)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Stloc, var)</span><br></pre></td></tr></table></figure>
<p>The functions <em>emitGt</em> and <em>emitLt</em> increment and decrement the data pointer by leveraging the previously defined add/sub functions.  This is also an important place to mention type safety (See, I said I’d get back to that).  I can ensure that I don’t ever accidently send anything other than the data pointer into these functions.  That can simply be done with a <code>(dataPointer:DpPointer)</code>, but I want to do a bit more; I want to use the <code>LocalBuilder</code> value within the type.  If you’re not familar with the syntax, <code>(DP(dataPointer):DpPointer)</code> effectively ensures that <em>dataPointer</em> is of type <em>DpPointer</em>, and extracts the <em>LocalBuilder</em> instance into the <em>dataPointer</em> variable.  This is a nice construct to not only ensure I send in a <em>LocalBuilder</em>, but that I send in the correct <em>LocalBuilder</em>.  The additional level of security is one of the strengths type safety brings to the table.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment dataPointer</span></span><br><span class="line"><span class="keyword">let</span> emitGt (ilGenerator:ILGenerator) (DP(dataPointer):DpPointer) = </span><br><span class="line">    addLocalInt ilGenerator dataPointer <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Decrement dataPointer</span></span><br><span class="line"><span class="keyword">let</span> emitLt (ilGenerator:ILGenerator) (DP(dataPointer):DpPointer) = </span><br><span class="line">    subLocalInt ilGenerator dataPointer <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><em>emitPlus</em> and <em>emitMinus</em> increment and decrement the value at data[dataPointer], respectively.  This is similar to before, the primary difference is how to get/set an array value.  Also note that again I use F# types to ensure I am only ever working with the <em>data[]</em> and <em>dataPointer</em> variables.  To get a value from an array onto the stack I push the array variable reference on the stack <code>Ldloc &lt;array variable&gt;</code>, then the index <code>Ldloc &lt;index&gt;</code>, then a command to push the value at array[index] onto the stack <code>Ldelem_I4</code>.  To set a value of an array the process is similar.  Push the array reference, index, and value on the stack, then call a command to pop the top value of the stack into array[index], <code>Stelem_I4</code>.  Beyond getting values in and out of arrays, I just have to do the appropriate add/subtract to the value before doing the set.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment value in data[dataPointer]</span></span><br><span class="line"><span class="keyword">let</span> emitPlus (ilGenerator:ILGenerator) (MEM(data):MemArray) (DP(dataPointer):DpPointer) =  </span><br><span class="line">    <span class="comment">// Load array reference for setting</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, data)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, dataPointer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load value of array</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, data)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, dataPointer)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldelem_I4)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add 1 to value</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldc_I4_1)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Add)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save back into array</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Stelem_I4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decrement value in data[dataPointer]</span></span><br><span class="line"><span class="keyword">let</span> emitMinus (ilGenerator:ILGenerator) (MEM(data):MemArray) (DP(dataPointer):DpPointer) =  </span><br><span class="line">    <span class="comment">// Load array reference for setting</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, data)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, dataPointer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load value of array</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, data)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, dataPointer)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldelem_I4)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subtract 1 to value</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldc_I4_1)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Sub)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save back into array</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Stelem_I4)</span><br></pre></td></tr></table></figure>
<p>Now it is time to tackle the IO portion of BF.  <em>emitComma</em> reads a character from stdin and saves it into <em>data[dataPointer]</em>.  To do this, I need to read the keypress from the console and convert it to a char.  In F# I would do <code>let (keypressChar:char) = Console.ReadKey().KeyChar</code>.  Using straight IL, I call the <code>ReadKey</code> and <code>get_KeyChar</code> functions.  After that, it is a matter of saving the value into the data array as an int. <em>emitPeriod</em> displays the value at <em>data[dataPointer]</em> to stdout as a char.  There isn’t a lot new here, push the value from the array onto the stack, then call <code>Console.Write</code>.  Of possible interest here is the parameter type char.  If I make the parameter type be <code>typeof&lt;int&gt;</code>, it would instead print the actual int value in the data array.  Although not what I want as final output, its a useful note for debugging.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read char from stdin into data[dataPointer]</span></span><br><span class="line"><span class="keyword">let</span> emitComma (ilGenerator:ILGenerator) (MEM(data):MemArray) (DP(dataPointer):DpPointer) =</span><br><span class="line">    <span class="comment">// Read keypress and extract char value</span></span><br><span class="line">    <span class="keyword">let</span> consoleReadKey = createLocal ilGenerator typeof&lt;System.ConsoleKeyInfo&gt;</span><br><span class="line">    ilGenerator.EmitCall(OpCodes.Call, typeof&lt;Console&gt;.GetMethod(<span class="string">"ReadKey"</span>, [| |]), [| typeof&lt;ConsoleKeyInfo&gt; |])</span><br><span class="line">    ilGenerator.Emit(OpCodes.Stloc, consoleReadKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> keypressChar = createLocal ilGenerator typeof&lt;char&gt;</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloca_S, consoleReadKey)</span><br><span class="line">    ilGenerator.EmitCall(OpCodes.Call, typeof&lt;ConsoleKeyInfo&gt;.GetMethod(<span class="string">"get_KeyChar"</span>, [| |]), [| typeof&lt;char&gt; |])</span><br><span class="line">    ilGenerator.Emit(OpCodes.Stloc, keypressChar)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save into data[dataPointer]</span></span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, data)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, dataPointer)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, keypressChar)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Stelem_I4)</span><br><span class="line">		</span><br><span class="line"><span class="comment">// Print char at data[dataPointer] to stdout</span></span><br><span class="line"><span class="keyword">let</span> emitPeriod (ilGenerator:ILGenerator) (MEM(data):MemArray) (DP(dataPointer):DpPointer) =</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, data)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldloc, dataPointer)</span><br><span class="line">    ilGenerator.Emit(OpCodes.Ldelem_I4)</span><br><span class="line">    ilGenerator.EmitCall(OpCodes.Call,typeof&lt;Console&gt;.GetMethod(<span class="string">"Write"</span>, [| typeof&lt;char&gt; |]), <span class="keyword">null</span>); </span><br></pre></td></tr></table></figure>
<p>Now that all the <em>ActionOps</em> are implemented, I make a generic <em>emitOp</em> function.  There isn’t anything particularly exciting here.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generate IL for an operator</span></span><br><span class="line"><span class="keyword">let</span> emitOp (ilGenerator:ILGenerator) (op:ActionOps) (data:MemArray) (dataPointer:DpPointer) =</span><br><span class="line">    <span class="keyword">match</span> op <span class="keyword">with</span> </span><br><span class="line">    | Gt    -&gt; emitGt ilGenerator dataPointer</span><br><span class="line">    | Lt    -&gt; emitLt ilGenerator dataPointer</span><br><span class="line">    | Plus  -&gt; emitPlus ilGenerator data dataPointer</span><br><span class="line">    | Minus -&gt; emitMinus ilGenerator data dataPointer</span><br><span class="line">    | Read  -&gt; emitComma ilGenerator data dataPointer</span><br><span class="line">    | Write -&gt; emitPeriod ilGenerator data dataPointer</span><br></pre></td></tr></table></figure>
<p>Time to implement loop blocks, program, and ast processor.  These are mutually recursive functions.  For those new to F#, this is accomplished by <code>let rec foo = &lt;foo code&gt; and bar &lt;bar code&gt;</code> syntax.  It is a necessary construct when foo needs to call bar, and vice versa.</p>
<p>The loop is a list of operators, with an associated predicate to determine if the list should continue to execute.  To do this the loop leverages labels for jumping between sections of code (the predicate section and the end of loop).  This is done in a two step process.  One, call <code>DefineLabel()</code> to create the label, this allows it to be referenced.  Two, <code>MarkLabel</code> says where in the code the label belongs.  As you can imagine, I put the predicate label at the begining of the predicate, and the loop-end label after the loop’s block of code.  </p>
<p>Tackling the predicate logic; the looping works as follows, “Continue loop as long as data[dataPointer] != 0”.  To test this, I push the value from the array onto the stack, then a 0.  <code>Ceq</code> does the compare, pushing the result onto the stack and <code>Brtrue</code> branches out of the loop if the value equals 0.</p>
<p>Once the branching logic is complete, all that’s left is processing the list of ops.  This is a good segue to <em>emitOpList</em>.  Both a loop and program are a list of operators.  This is simply a matter of iterating over the list and feeding each one into <em>processAst</em>.</p>
<p>Even though <em>processAst</em> is the controlling function for the emitting of the AST -&gt; IL, it looks pretty tame to everything else so far.  But that’s because the hard stuff has already been done.  <em>processAst</em> provides a match that handles the 3 types of operators; and their respective functions take care of the rest of the work.  </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Generate IL for a loop</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> emitLoop (ilGenerator:ILGenerator) (MEM(data):MemArray) (DP(dataPointer):DpPointer) (block:AllOps list) =</span><br><span class="line">      <span class="keyword">let</span> ilLoopPredicate = ilGenerator.DefineLabel()</span><br><span class="line">      <span class="keyword">let</span> ilLoopStart = ilGenerator.DefineLabel()</span><br><span class="line">      <span class="keyword">let</span> ilLoopEnd = ilGenerator.DefineLabel()</span><br><span class="line">      </span><br><span class="line">      <span class="comment">////////////</span></span><br><span class="line">      <span class="comment">// predicate</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// push data[dataPointer]</span></span><br><span class="line">      ilGenerator.MarkLabel(ilLoopPredicate)</span><br><span class="line">      ilGenerator.Emit(OpCodes.Ldloc, data)</span><br><span class="line">      ilGenerator.Emit(OpCodes.Ldloc, dataPointer)</span><br><span class="line">      ilGenerator.Emit(OpCodes.Ldelem_I4)</span><br><span class="line">      <span class="comment">// push 0</span></span><br><span class="line">      ilGenerator.Emit(OpCodes.Ldc_I4, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if true (data[dataPointer]==0), exit loop</span></span><br><span class="line">      ilGenerator.Emit(OpCodes.Ceq)</span><br><span class="line">      ilGenerator.Emit(OpCodes.Brtrue, ilLoopEnd)</span><br><span class="line"></span><br><span class="line">      <span class="comment">/////////////</span></span><br><span class="line">      <span class="comment">// loop block</span></span><br><span class="line">      ilGenerator.MarkLabel(ilLoopStart)</span><br><span class="line">      emitOpList ilGenerator (MEM data) (DP dataPointer) block</span><br><span class="line"></span><br><span class="line">      <span class="comment">//////////////</span></span><br><span class="line">      <span class="comment">// End of loop</span></span><br><span class="line">      ilGenerator.Emit(OpCodes.Br, ilLoopPredicate)</span><br><span class="line">      ilGenerator.MarkLabel(ilLoopEnd)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate IL for list of Ops</span></span><br><span class="line">  <span class="keyword">and</span> emitOpList (ilGenerator:ILGenerator) (data:MemArray) (dataPointer:DpPointer) (ast:AllOps list) =</span><br><span class="line">      ast |&gt; List.iter (processAst ilGenerator data dataPointer)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate IL for ast</span></span><br><span class="line">  <span class="keyword">and</span> processAst (ilGenerator:ILGenerator) (data:MemArray) (dataPointer:DpPointer) (ast:AllOps) =</span><br><span class="line">      <span class="keyword">match</span> ast <span class="keyword">with</span></span><br><span class="line">      | Op op         -&gt; emitOp ilGenerator op data dataPointer</span><br><span class="line">      | Loop block    -&gt; emitLoop ilGenerator data dataPointer block</span><br><span class="line">      | Program block -&gt; emitOpList ilGenerator data dataPointer block</span><br><span class="line">| Comment       -&gt; () <span class="comment">// do nothing</span></span><br></pre></td></tr></table></figure>
<p>Taking a breather from all that new stuff, I head back into familiar territory.  This is the code from my second post in the series; emitting an IL program.  The only change of significance is that I now insert the BF logic.  This consists of creating the necessary variables and generating IL based on the AST.  First, the variables: <em>data</em>, <em>dataPointer</em>, and <em>programCounter</em>.  As mentioned above I don’t need <em>programCounter</em>, so it’s here for reference only.  I use my previously defined “create variable” functions for this.  I also wrap each variable in it’s respective type (MEM, DP, PC).  This ensures that as I use them, I don’t send the wrong variable to the wrong function.  Second, the IL generation with <em>processAst</em>.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove non-alphanumeric, to avoid object naming issues</span></span><br><span class="line"><span class="keyword">let</span> cleanName name = </span><br><span class="line">    <span class="keyword">let</span> regEx = <span class="keyword">new</span> Regex(<span class="string">"[^A-Z0-9]"</span>, RegexOptions.IgnoreCase)</span><br><span class="line">    regEx.Replace(name, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create and save exe, emits IL inside application "shell"</span></span><br><span class="line"><span class="keyword">let</span> createProgram (appName:string) (ast:AllOps list) =</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> appName' = cleanName appName</span><br><span class="line">    <span class="keyword">let</span> exeName = sprintf <span class="string">"%s.exe"</span> appName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> appDomain = AppDomain.CurrentDomain</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> assemblyName = <span class="keyword">new</span> AssemblyName()</span><br><span class="line">    assemblyName.Name &lt;- appName'</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> assembly = appDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Save)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> programModule = assembly.DefineDynamicModule(appName', exeName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> appClass = sprintf <span class="string">"%s.Program"</span> appName'</span><br><span class="line">    <span class="keyword">let</span> programType = programModule.DefineType(appClass, TypeAttributes.Public)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mainMethod = programType.DefineMethod(<span class="string">"Main"</span>, MethodAttributes.Static)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define starting method for assembly</span></span><br><span class="line">    assembly.SetEntryPoint(mainMethod)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mainIl = mainMethod.GetILGenerator()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Contents of function: Main</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// IL Variable initialization</span></span><br><span class="line">    <span class="keyword">let</span> data = MEM(createLocalArray mainIl typeof&lt;int[]&gt; memorySize)</span><br><span class="line">    <span class="keyword">let</span> dataPointer = DP(createLocal mainIl typeof&lt;int&gt;)</span><br><span class="line">    <span class="comment">//let programCounter = PC(createLocal mainIl typeof&lt;int&gt;)</span></span><br><span class="line"></span><br><span class="line">    processAst mainIl data dataPointer (Program ast)</span><br><span class="line"></span><br><span class="line">    mainIl.Emit(OpCodes.Ret)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the Foo.Program class </span></span><br><span class="line">    programType.CreateType() |&gt; ignore</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save exe</span></span><br><span class="line">    assembly.Save(exeName)</span><br></pre></td></tr></table></figure>
<p>Tying the parser and emitter is done in the compile function.  FParsec provides a Success/Failure when parsing a string.  In this case, if success I emit a compiled program, otherwise I display the parsing error.  I also filter out the comments prior to sending it to emitter.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Compiler = </span><br><span class="line">    <span class="keyword">let</span> compile appName code = </span><br><span class="line">        <span class="keyword">let</span> ast = Parser.buildAst code</span><br><span class="line">        <span class="keyword">match</span> ast <span class="keyword">with</span></span><br><span class="line">        | Success(x, _, _) -&gt; Emitter.createProgram appName (x |&gt; List.filter (<span class="keyword">fun</span> x' -&gt; x' &lt;&gt; Comment))</span><br><span class="line">        | Failure(e, _, _) -&gt; printfn <span class="string">"Error: %A"</span> e</span><br></pre></td></tr></table></figure>
<p>Here is a compilation of a Hello World program.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> programName = <span class="string">"HelloWorld"</span></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">"++++++++++++[&gt;++++++&gt;++++++++&gt;+++&lt;&lt;&lt;-]&gt;.&gt;+++++.+++++++..+++.&gt;----.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+."</span> </span><br><span class="line"></span><br><span class="line">Compiler.compile programName code</span><br></pre></td></tr></table></figure>
<p>Quite exciting, it worked!</p>
<p><img src="/images/bf1/helloworld_execute.png" alt="Hello World"></p>
<p>Taking it a bit further, I can compile bf files from the commandline.  To support this I remove the <em>programName</em> and <em>code</em> variables, and replace them with the below block.  This will compile all *.bf files provided as arguments.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment.GetCommandLineArgs()   </span><br><span class="line">|&gt; Array.filter (<span class="keyword">fun</span> (x:string) -&gt; x.EndsWith(<span class="string">".bf"</span>))</span><br><span class="line">|&gt; Array.iter (<span class="keyword">fun</span> x -&gt;</span><br><span class="line">     printfn <span class="string">"compiling %s ..."</span> x</span><br><span class="line">     Compiler.compile x (File.ReadAllText x))</span><br></pre></td></tr></table></figure>
<p>The primary goal is complete.  I can now compile BF to run in the CLR.  There are a couple directions I could follow at this point.  Next time, going deeper down the rabbit hole: optimization.</p>

        <div class="related-posts-box">
        Related Posts:<ul class="related-posts"><li class="related-posts-item"><a class="related-posts-link" href="/2017/03/13/bf-compiler-part4-optimization/">BF Compiler Part 4 - Optimization</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2017/02/19/bf-compiler-part1-parsing/">BF Compiler Part 1 - Parsing</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2017/02/26/bf-compiler-part2-msil/">BF Compiler Part 2 - MSIL</a></li></ul>        </div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://codesuji.com/2017/03/04/bf-compiler-part3-compiler/" data-id="ckgqhw6x200aml1mw7mtw4u8c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Compiler/">Compiler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/F/">F#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FParsec/">FParsec</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FSharp/">FSharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MSIL/">MSIL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Parsing/">Parsing</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/13/bf-compiler-part4-optimization/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          BF Compiler Part 4 - Optimization
        
      </div>
    </a>
  
  
    <a href="/2017/02/26/bf-compiler-part2-msil/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">BF Compiler Part 2 - MSIL</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/NET-Core/" style="font-size: 17.78px;">.NET Core</a> <a href="/tags/Accord-NET/" style="font-size: 15.56px;">Accord.NET</a> <a href="/tags/Analytics/" style="font-size: 14.44px;">Analytics</a> <a href="/tags/Audio/" style="font-size: 10px;">Audio</a> <a href="/tags/Benchmarking/" style="font-size: 10px;">Benchmarking</a> <a href="/tags/Chiron/" style="font-size: 10px;">Chiron</a> <a href="/tags/Classification/" style="font-size: 11.11px;">Classification</a> <a href="/tags/Cognitive-Services/" style="font-size: 11.11px;">Cognitive Services</a> <a href="/tags/Compiler/" style="font-size: 13.33px;">Compiler</a> <a href="/tags/Computer-Vision/" style="font-size: 11.11px;">Computer Vision</a> <a href="/tags/Cordova/" style="font-size: 10px;">Cordova</a> <a href="/tags/DTW/" style="font-size: 14.44px;">DTW</a> <a href="/tags/Data/" style="font-size: 16.67px;">Data</a> <a href="/tags/Database/" style="font-size: 11.11px;">Database</a> <a href="/tags/Decision-Trees/" style="font-size: 11.11px;">Decision Trees</a> <a href="/tags/Deedle/" style="font-size: 10px;">Deedle</a> <a href="/tags/Delegate/" style="font-size: 10px;">Delegate</a> <a href="/tags/Detection/" style="font-size: 10px;">Detection</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Dynamic-Time-Warping/" style="font-size: 13.33px;">Dynamic Time Warping</a> <a href="/tags/EEG/" style="font-size: 10px;">EEG</a> <a href="/tags/Edges/" style="font-size: 10px;">Edges</a> <a href="/tags/Education/" style="font-size: 10px;">Education</a> <a href="/tags/Elmish/" style="font-size: 10px;">Elmish</a> <a href="/tags/EmguCV/" style="font-size: 10px;">EmguCV</a> <a href="/tags/Entropy/" style="font-size: 10px;">Entropy</a> <a href="/tags/F/" style="font-size: 20px;">F#</a> <a href="/tags/FParsec/" style="font-size: 12.22px;">FParsec</a> <a href="/tags/FSAdvent/" style="font-size: 10px;">FSAdvent</a> <a href="/tags/FSharp/" style="font-size: 20px;">FSharp</a> <a href="/tags/Fable/" style="font-size: 10px;">Fable</a> <a href="/tags/Faces/" style="font-size: 11.11px;">Faces</a> <a href="/tags/Filters/" style="font-size: 10px;">Filters</a> <a href="/tags/Http/" style="font-size: 11.11px;">Http</a> <a href="/tags/Images/" style="font-size: 12.22px;">Images</a> <a href="/tags/Ionide/" style="font-size: 10px;">Ionide</a> <a href="/tags/Kaggle/" style="font-size: 12.22px;">Kaggle</a> <a href="/tags/Keyboard/" style="font-size: 13.33px;">Keyboard</a> <a href="/tags/Legos/" style="font-size: 11.11px;">Legos</a> <a href="/tags/Logging/" style="font-size: 10px;">Logging</a> <a href="/tags/MLNet/" style="font-size: 16.67px;">MLNet</a> <a href="/tags/MSIL/" style="font-size: 12.22px;">MSIL</a> <a href="/tags/Machine-Learning/" style="font-size: 18.89px;">Machine Learning</a> <a href="/tags/MathNet/" style="font-size: 10px;">MathNet</a> <a href="/tags/Messaging/" style="font-size: 10px;">Messaging</a> <a href="/tags/Mobile/" style="font-size: 10px;">Mobile</a> <a href="/tags/Mono/" style="font-size: 10px;">Mono</a> <a href="/tags/Morse-Code/" style="font-size: 10px;">Morse Code</a> <a href="/tags/Mqtt/" style="font-size: 12.22px;">Mqtt</a> <a href="/tags/Nix/" style="font-size: 10px;">Nix</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/Parsing/" style="font-size: 12.22px;">Parsing</a> <a href="/tags/Performance/" style="font-size: 10px;">Performance</a> <a href="/tags/Presentations/" style="font-size: 10px;">Presentations</a> <a href="/tags/Propagator/" style="font-size: 10px;">Propagator</a> <a href="/tags/Racket/" style="font-size: 10px;">Racket</a> <a href="/tags/Regression/" style="font-size: 10px;">Regression</a> <a href="/tags/Rekognition/" style="font-size: 10px;">Rekognition</a> <a href="/tags/Robotics/" style="font-size: 10px;">Robotics</a> <a href="/tags/Rust/" style="font-size: 10px;">Rust</a> <a href="/tags/STEM/" style="font-size: 11.11px;">STEM</a> <a href="/tags/Scoring/" style="font-size: 10px;">Scoring</a> <a href="/tags/Search/" style="font-size: 10px;">Search</a> <a href="/tags/Serialization/" style="font-size: 10px;">Serialization</a> <a href="/tags/SignalR/" style="font-size: 10px;">SignalR</a> <a href="/tags/Signals/" style="font-size: 12.22px;">Signals</a> <a href="/tags/Similarity/" style="font-size: 11.11px;">Similarity</a> <a href="/tags/Sound/" style="font-size: 10px;">Sound</a> <a href="/tags/Statistics/" style="font-size: 13.33px;">Statistics</a> <a href="/tags/Tail-calls/" style="font-size: 10px;">Tail calls</a> <a href="/tags/Text/" style="font-size: 14.44px;">Text</a> <a href="/tags/Timeseries/" style="font-size: 10px;">Timeseries</a> <a href="/tags/Tips/" style="font-size: 11.11px;">Tips</a> <a href="/tags/Translation/" style="font-size: 10px;">Translation</a> <a href="/tags/VS-Code/" style="font-size: 10px;">VS Code</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Webapi/" style="font-size: 11.11px;">Webapi</a> <a href="/tags/admin/" style="font-size: 11.11px;">admin</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/09/F-Scripting/">F# Scripting</a>
          </li>
        
          <li>
            <a href="/2020/12/12/Mqtt-Server-FSharp-3/">Building an MQTT server in F# - Part 3</a>
          </li>
        
          <li>
            <a href="/2020/11/29/Mqtt-Server-FSharp-2/">Building an MQTT server in F# - Part 2</a>
          </li>
        
          <li>
            <a href="/2020/11/22/Mqtt-Server-FSharp-1/">Building an MQTT server in F# - Part 1</a>
          </li>
        
          <li>
            <a href="/2020/11/05/Rust-and-Dynamic-Time-Warping/">Rust and Dynamic Time Warping</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 codesuji.com<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>