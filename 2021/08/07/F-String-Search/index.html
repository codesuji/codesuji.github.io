<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Examining Boyer-Moore String Search with F# | codesuji</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Text search is something we do everyday.  Fast and reliable search is such a staple, it is easy to forget there can be elegance to those underlying mechanisms.  It is time to pull back the curtain and">
<meta name="keywords" content="F#,FSharp,Search,Benchmarking,Algorithms">
<meta property="og:type" content="article">
<meta property="og:title" content="Examining Boyer-Moore String Search with F#">
<meta property="og:url" content="http://codesuji.com/2021/08/07/F-String-Search/index.html">
<meta property="og:site_name" content="codesuji">
<meta property="og:description" content="Text search is something we do everyday.  Fast and reliable search is such a staple, it is easy to forget there can be elegance to those underlying mechanisms.  It is time to pull back the curtain and">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2023-01-02T03:43:48.912Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Examining Boyer-Moore String Search with F#">
<meta name="twitter:description" content="Text search is something we do everyday.  Fast and reliable search is such a staple, it is easy to forget there can be elegance to those underlying mechanisms.  It is time to pull back the curtain and">
  
    <link rel="alternate" href="/atom.xml" title="codesuji" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89982547-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">codesuji</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://codesuji.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-F-String-Search" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/07/F-String-Search/" class="article-date">
  <time datetime="2021-08-07T13:28:19.000Z" itemprop="datePublished">2021-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Examining Boyer-Moore String Search with F#
    </h1>
  

 		<span class="post-count">Read Time: 19 minutes</span>
 	  </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Text search is something we do everyday.  Fast and reliable search is such a staple, it is easy to forget there can be elegance to those underlying mechanisms.  It is time to pull back the curtain and dig into one of the foundational search algorithms, the Boyer-Moore fast string search.  It is a good algorithm to demonstrate some of the methods used to achieve fast search results.  As typical, I’ll reach for <a href="https://fsharp.org" target="_blank" rel="noopener">F#</a> to show implementation details.</p>
<a id="more"></a>
<p>For reference, most of what I discuss is pulled from Boyer and Moore’s 1977 paper <a href="/images/fss1/fstrpos.pdf">A Fast String Searching Algorithm</a>.  If you want to read it straight from the source, its a easy to digest paper.  One of the things I love about this algorithm is the cleverness in understanding how the structure of the data can enhance the goal.  This results in an elegant solution.  It also strikes the right balance.  It contains some complexity, but its a comprehendable algorithm without the burden of being too clever.</p>
<p>Before digging into the algorithm, its worth setting a baseline.  For that I’ll use a naive search.  It starts at the beginning of a string, iterates character by character, checking to see if it matches the first character of the pattern. If/When it hits a character match, it checks deeper into the pattern.  If it mismatches within the pattern, it backtracks and continues from where it left off.  It’s intent is the simplest, most straight-forward approach.  Once I have an extremely basic approach, I can dig into how Boyer-Moore improves upon this concept.  Below is an example of how the process works, and how long it takes to find the pattern “coffeecake” in the string.</p>
<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Naive Method:
Step 1:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern: coffeecake
         &#8593;

Step 2:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:  coffeecake
          &#8593;

Step 3:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:   coffeecake
           &#8593;
...
Step 38:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:                                coffeecake
                                        &#8593;
...
Step 47:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:                                coffeecake
                                                 &#8593;
</pre>

<p>The example above takes 47 comparisons from start to finish.  Some of this is taken by backtracking when it finds a partial match at “coffee”. Most of the time is taken by the fact that it has to go character by character.</p>
<p>If you haven’t guessed by now, there is a better way.  There are a couple preliminary aspects of the Boyer-Moore algorithm to establish.  First, when doing pattern compares, it starts at the end of the pattern.  For the pattern “coffeecake”, it’ll try to match the final ‘e’, then ‘k’, etc. At a minimum, this gives it a bit of a jump start by skipping nearly the length of the search string for non-matches.  This isn’t the big optimization, but this dynamic will come into play later.  Second, the algorithm uses a preprocessing step prior to the actual search.  This is the meat of the optimizations.  It builds up information regarding the search string that allows it to make more efficient choices during the search.  This process leverages knowledge of the pattern’s structure to improve the scanning process.</p>
<p>The first optimization is a simple one involving a lookup table (described as delta 1 in the paper).  Prior to the search, it makes a pass through the pattern.  During which a table is built for each possible character, and how many positions it can increment the search pointer if the character it hits doesn’t match against the current character in the pattern.  If the character isn’t in the pattern, then it knows it can skip over it entirely, which translates to incrementing the pointer the length of the pattern.  If the character is in the pattern, it determines the last instance of that character within the pattern and uses that to calculate the number of characters that can be skipped. The formula in that case is: patternLength - index - 1.  The result is being able to increment by multiple positions in the string when the current character doesn’t match.  For illustrative purposes, below is an example.</p>
<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Pattern: coffeecake
Index  : 0123456789

Resulting lookup table (abbreviated):
a: 2 (10 - 7 - 1)
b: 10
c: 3 (10 - 6 - 1)
d: 10
e: 0 (10 - 9 - 1)
f: 6  (10 - 3 - 1)
g: 10
...
z: 10
</pre>

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Step 1:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern: coffeecake
Pointer:          &#8593;
</pre>
Action: It compares ' ' to 'e'.  Looking at the lookup table, blank doesn't exist in the pattern, so it can jump ahead 10 positions.

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Step 2:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:           coffeecake
Pointer:                    &#8593;
</pre>
Action: It compares 'f' to 'e'.  They don't match, but it does know that f exists in the pattern, using the lookup table it can increment 6.

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Step 3:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:                 coffeecake
Pointer:                          &#8593;
</pre>
Action: Now it is aligned with the previously seen 'f' with an 'f' in the pattern.  The goal here is to jump ahead as far as it can, while attempting alignment with the string and pattern.  This is good, although as you can see, it will now compare 't' with 'e'.  Since 't' isn't in the pattern, it will increment 10 positions.

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Step 4:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:                           coffeecake
Pointer:                                    &#8593;
</pre>
Action: Here it find a match, the 'e' matches in the string and pattern. This means it can start comparing backward through the pattern.

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Step 5:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:                           coffeecake
Pointer:                                   &#8593;
</pre>
Action: Here 'f' doesn't match 'k', but exists in the pattern, as before, it can increment 6 positions.

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Step 6:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:                                coffeecake
Pointer:                                         &#8593;
</pre>
Action:  Again, it aligned the 'f' from string with the 'f' in the pattern.  It get a hit with 'e', so it will start walking backwards through the pattern.  We can also see at this point we've found our match, the algorithm just doesn't know it yet.

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Steps 7-15:
String : I like to drink coffee with my coffeecake at breakfast.
Pattern:                                coffeecake
Pointer:                                        &#8593;
Pointer:                                       &#8593;
...
Pointer:                                &#8593;
</pre>

<p>Action: As you can see, it is in the match. Steps 7 - 15 will be walking backwards through the pattern until it verifies the match.</p>
<p>What this shows in a total of 15 compares it found the match.  A naive character-by-character check takes considerably more than that.  This is a simple example, but a third the number of checks on a small example feels like a good optimization.  One attribute of this method is longer search patterns allow the algorithm to jump through the string faster on non-matching characters.  How much is obviously pattern specific, but anything is better than one character at a time.  What does this lookup table construction look like in code?  It’s always a joy when we can get such benefits from something so direct.  As a performance sidenote, it is very tempting to build a Map for character lookup, it feels very natural.  Unfortunantly the overhead of using Map in this particular case is high enough to be an issue, so using an array for character lookup is fast enough to be worth the effort.  It is a reminder of the constant trade-offs that need to be made when looking for performance.  </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Build the delta 1 table</span></span><br><span class="line"><span class="comment">/// If the char is in the string, it is the rightmost value,</span></span><br><span class="line"><span class="comment">/// otherwise it is the length of the pattern.</span></span><br><span class="line"><span class="keyword">let</span> buildDelta1 (pattern: string) =</span><br><span class="line">  <span class="keyword">let</span> patternLength = pattern.Length </span><br><span class="line"></span><br><span class="line">  [| <span class="number">0.</span><span class="number">.127</span> |]</span><br><span class="line">  |&gt; Array.map (<span class="keyword">fun</span> x -&gt;</span><br><span class="line">      <span class="keyword">let</span> c = char x</span><br><span class="line">      <span class="keyword">let</span> index = pattern.LastIndexOf(c)</span><br><span class="line">      <span class="keyword">if</span> index = <span class="number">-1</span> <span class="keyword">then</span> patternLength <span class="keyword">else</span> patternLength - index - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>This is great, but Boyer and Moore didn’t stop there, they realized there is even more structure they can extract and leverage from within the pattern.  If a subpattern is repeated within the pattern, there is more that can be done, this is the second optimization.  It is focused on the subpattern anchored at the end of the pattern.  The primary reason for this is searching through the pattern starts at the end and moves backward.  it can use this information in cases where it have started matching against the pattern, but cannot match any further.  It gains the benefit from a repetition of a terminal subpattern, potentially allowing an optimization over the first methodology.</p>
<p>To build the delta 2 table it looks at the iteratively growing terminal subpatterns.  Looking at the previous example pattern “coffeecake”, that means “e” then “ke”, then “ake”, etc.  To look at the final “e”, although short is a pattern.  Understanding the circumstances to get partway through a match is important.  It is not looking for just another “e”, it specifically wants an “e” not preceded by a “k”.  This is an important distinction.  This is because it is trying to smartly shift to another part of the search string.  But it doesn’t need to do that when it has matched the “ke”, it needs it when there is an “e”, but can’t match the next letter “k”.  Knowing this allows the algorithm to do a smarter alignment if it gets a partial match “e”, but the subpattern stops matching at ‘k’. This is done for all terminal subpatterns. So next, is there another instance of “ke” not preceded by “a”.  Then is there another “ake” not preceded by “c”.  This goes through the entire set of terminal subpatterns.  This is only part of the case.  The other case is what if there is no “e” that isn’t preceded by a “k”.  In cases like this, it knows how far into the pattern match it is, and can do a larger shift as a result when it finds a character that doesn’t match.  Below is the resulting table of pattern shifts based on subpattern, as well as an example use.</p>
<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Resulting lookup table for pattern indexes:
0 (c): 19 
1 (o): 18
2 (f): 17 
3 (f): 16 
4 (e): 15
5 (e): 14
6 (c): 13
7 (a): 12
8 (k):  5
9 (e):  1
</pre>

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Example 1: 
String : Some coffee pairs well with coffeecake in the morning.
Pattern: coffeecake
Pointer:         &#8593;
</pre>
Action: When it is matching backwards through the pattern, it has matched the 'e', but don't match the 'k'.  Here is where it leverages the knowledge that there is an 'e' not preceded by a 'k' pattern earlier. So it can shift 5 positions.

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
String : Some coffee pairs well with coffeecake in the morning.
Pattern:      coffeecake
Pointer:               &#8593;
</pre>
Action: As you can see, the shift aligned the 'e' between the main string and search string, attempting to optimize the search.

<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
Example 2: 
String : Small cake is not a match.
Pattern: coffeecake
Pointer       &#8593;
</pre>
Action: Here is a different case.  It matchs the ' cake' part of the pattern.  Then it mismatch on the ' ' versus 'e'.  It also knows the terminal subpattern isn't seen again.  At this point it can jump past what it has already matched so far.


<pre style="font-family: monospace; font-size: 10pt; background: #ffffff; color: #000000;border: none;">
String : Small cake is not a match.
Pattern:           coffeecake
Pointer:                    &#8593;
</pre>

<p>Building this lookup table takes a bit more work than the delta1 table.  Searching for the best subpattern match within a string takes a couple steps.  This is the most complex part of the preprocessing since it needs to perform multiple scans through the pattern.  This is a good place to mention that Boyer-Moore does involve some overhead.  In many cases, building the preprocessing tables can dominate the overall search.  It is important to make this part as fast as possible.  For performance I use arrays, indexes, and mutables instead of passing strings around.  It is not my preference, but it is a necessary tradeoff.  The performance cost is too much to bear in this part of the algorithm.  </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: rpr is an index from the end of pattern</span></span><br><span class="line"><span class="keyword">let</span> findRpr (pattern:string) (candidateStartIndex: int) (candidateStopIndex: int) :int =</span><br><span class="line">  <span class="keyword">let</span> patternLength = pattern.Length</span><br><span class="line">  <span class="keyword">let</span> candidateLength = candidateStopIndex - candidateStartIndex + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> findRpr' i =</span><br><span class="line">    <span class="keyword">if</span> i &gt;= patternLength || i &gt;= candidateLength <span class="keyword">then</span> i</span><br><span class="line">    <span class="keyword">elif</span> pattern.[patternLength - <span class="number">1</span> - i] &lt;&gt; pattern.[candidateStartIndex + (candidateLength - <span class="number">1</span> - i)] <span class="keyword">then</span> i</span><br><span class="line">    <span class="keyword">else</span> findRpr' (i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  findRpr' <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Check if the pattern starts with the suffix starting at the defined index</span></span><br><span class="line"><span class="comment">/// For my purposes, this is faster than String.StartsWith</span></span><br><span class="line"><span class="keyword">let</span> startsWithSuffix (pattern: string) (subPatternStart: int) :bool =</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> startsWithSuffix' i j =</span><br><span class="line">    <span class="keyword">if</span> j = pattern.Length <span class="keyword">then</span> <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">elif</span> i = pattern.Length <span class="keyword">then</span> <span class="keyword">false</span></span><br><span class="line">    <span class="keyword">elif</span> pattern.[i] &lt;&gt; pattern.[j] <span class="keyword">then</span> <span class="keyword">false</span></span><br><span class="line">    <span class="keyword">else</span> startsWithSuffix' (i + <span class="number">1</span>) (j + <span class="number">1</span>)</span><br><span class="line">  startsWithSuffix' <span class="number">0</span> subPatternStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Build delta2 table</span></span><br><span class="line"><span class="keyword">let</span> buildDelta2 (pattern: string) =</span><br><span class="line">  <span class="keyword">let</span> last = pattern.Length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> rprs = Array.create pattern.Length <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find rprs for pattern</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> [| <span class="number">0</span> .. (last - <span class="number">1</span>) |] <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> rpr = findRpr pattern <span class="number">1</span> i</span><br><span class="line">    <span class="keyword">if</span> pattern.[i-rpr] &lt;&gt; pattern.[last-rpr] <span class="keyword">then</span></span><br><span class="line">      rprs.[last - rpr] &lt;- rpr + last - i</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If rpr isn't found for character, default to a shift based on index position (to handle rpr finding off left side</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> lastPrefix = last</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> [| last .. <span class="number">-1</span> .. <span class="number">0</span> |] <span class="keyword">do</span></span><br><span class="line">    <span class="comment">// Only do this where an rpr value wasn't found </span></span><br><span class="line">    <span class="keyword">if</span> startsWithSuffix pattern (i + <span class="number">1</span>) <span class="keyword">then</span> lastPrefix &lt;- i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> rprs.[i] = <span class="number">0</span> <span class="keyword">then</span> rprs.[i] &lt;- lastPrefix + last - i</span><br><span class="line"></span><br><span class="line">  rprs </span><br></pre></td></tr></table></figure>
<p>Now that I have the two parts, they just need put together.  At each step, the current character in the string attempts to match the current character in the pattern.  If it matches, it keeps trying to match the pattern.  If it doesn’t match, the search index is incremented the maximum of the delta1 and delta2 tables.  This allows the algorithm to jump as far as possible, using the available pattern structural information.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Find pattern in string using a Boyer-Moore fast string search method</span></span><br><span class="line"><span class="keyword">let</span> fastSearch (pattern: string) (s: string) :int option =</span><br><span class="line">  <span class="keyword">let</span> delta1 = buildDelta1 pattern</span><br><span class="line">  <span class="keyword">let</span> delta2 = buildDelta2 pattern</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> fastSearch' stringPosition patternPosition =</span><br><span class="line">    <span class="keyword">if</span> patternPosition &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">      None</span><br><span class="line">    <span class="keyword">elif</span> stringPosition &gt;= s.Length <span class="keyword">then</span></span><br><span class="line">      <span class="comment">// At end of string, pattern not found</span></span><br><span class="line">      None</span><br><span class="line">    <span class="keyword">elif</span> patternPosition = <span class="number">0</span> &amp;&amp; s.[stringPosition] = pattern.[patternPosition] <span class="keyword">then</span></span><br><span class="line">      <span class="comment">// At the end of pattern, match found</span></span><br><span class="line">      Some stringPosition</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// If chars match, keep comparing (decrement both stringPosition &amp; patternPosition)</span></span><br><span class="line">      <span class="comment">// If chars don't match, jump ahead (stringPosition jumps by max of delta1 and delta2 tables, patternPosition is reset to end of pattern)</span></span><br><span class="line">      <span class="keyword">let</span> (stringPosition', patternPosition') = </span><br><span class="line">        <span class="keyword">if</span> s.[stringPosition] = pattern.[patternPosition] <span class="keyword">then</span></span><br><span class="line">          (stringPosition - <span class="number">1</span>, patternPosition - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          (stringPosition + max (delta1.[int s.[stringPosition]]) (delta2.[patternPosition]), pattern.Length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      fastSearch' stringPosition' patternPosition'</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> pattern.Length &gt; s.Length <span class="keyword">then</span></span><br><span class="line">    <span class="comment">// If pattern is longer than the string, it can't be found</span></span><br><span class="line">    None</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// Start searching</span></span><br><span class="line">    fastSearch' (pattern.Length - <span class="number">1</span>) (pattern.Length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>In a nutshell, these are the not-so-secret weapons of the algorithm.  As I’ve walked through some methods and examples, it becomes obvious it can leverage internal structure to implement smart jumps through the string.  These can provide orders of magnitude larger jumps than a naive search, which translates into a pretty hefty performance boost. Intuitively this makes sense, but a benchmark helps to provide some more concrete data.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|      Method | StringSize | PatternSize |         Mean |      Error |     StdDev |       Median |     Gen 0 |  Gen 1 | Gen 2 | Allocated |</span><br><span class="line">|------------ |----------- |------------ |-------------:|-----------:|-----------:|-------------:|----------:|-------:|------:|----------:|</span><br><span class="line">|  fastSearch |      10000 |          10 |    12.295 us |  0.0432 us |  0.0383 us |    12.294 us |    5.3711 |      - |     - |     33 KB |</span><br><span class="line">| naiveSearch |      10000 |          10 |    69.570 us |  0.1936 us |  0.1810 us |    69.589 us |   53.1006 |      - |     - |    326 KB |</span><br><span class="line">|  fastSearch |      10000 |          50 |     8.068 us |  0.1575 us |  0.1992 us |     8.178 us |    2.4719 |      - |     - |     15 KB |</span><br><span class="line">| naiveSearch |      10000 |          50 |    71.696 us |  0.2221 us |  0.2077 us |    71.774 us |   53.4668 |      - |     - |    328 KB |</span><br><span class="line">|  fastSearch |      10000 |         100 |     9.702 us |  0.1869 us |  0.2494 us |     9.852 us |    2.7924 |      - |     - |     17 KB |</span><br><span class="line">| naiveSearch |      10000 |         100 |    73.313 us |  0.1421 us |  0.1329 us |    73.284 us |   54.0771 |      - |     - |    331 KB |</span><br><span class="line">|  fastSearch |      10000 |        1000 |    41.977 us |  0.2469 us |  0.2309 us |    42.120 us |    9.8877 | 0.2441 |     - |     61 KB |</span><br><span class="line">| naiveSearch |      10000 |        1000 |    76.811 us |  0.1456 us |  0.1362 us |    76.796 us |   58.9600 |      - |     - |    362 KB |</span><br><span class="line">|  fastSearch |    1000000 |          10 |   989.763 us |  1.5934 us |  1.4905 us |   989.457 us |  476.5625 |      - |     - |  2,921 KB |</span><br><span class="line">| naiveSearch |    1000000 |          10 | 7,069.001 us | 29.2355 us | 27.3469 us | 7,068.265 us | 5312.5000 |      - |     - | 32,548 KB |</span><br><span class="line">|  fastSearch |    1000000 |          50 |   384.506 us |  0.5249 us |  0.4910 us |   384.562 us |  176.2695 | 0.4883 |     - |  1,081 KB |</span><br><span class="line">| naiveSearch |    1000000 |          50 | 6,928.350 us | 22.2543 us | 20.8167 us | 6,920.000 us | 5312.5000 |      - |     - | 32,549 KB |</span><br><span class="line">|  fastSearch |    1000000 |         100 |   266.840 us |  0.7624 us |  0.6759 us |   266.723 us |  120.6055 |      - |     - |    740 KB |</span><br><span class="line">| naiveSearch |    1000000 |         100 | 7,011.172 us | 77.9405 us | 72.9055 us | 6,968.868 us | 5312.5000 |      - |     - | 32,555 KB |</span><br><span class="line">|  fastSearch |    1000000 |        1000 |   433.229 us |  0.8704 us |  0.7716 us |   433.164 us |  191.4063 | 2.9297 |     - |  1,173 KB |</span><br><span class="line">| naiveSearch |    1000000 |        1000 | 6,994.461 us |  9.9059 us | 15.1274 us | 6,994.001 us | 5312.5000 |      - |     - | 32,580 KB |</span><br></pre></td></tr></table></figure>
<p>As always, you have to take benchmarks with a grain of salt, but the results do match our intuition of a performance boost.  As I mentioned earlier, the benefits can be highly dependent upon not only the length of the string and pattern, but of the strucutre of the data itself.  It at least shows on the surface what is possible.  Hopefully you have enjoyed this dive into the Boyer-Moore string search.  If you found this interesting, search can be a pretty deep topic and I encourage you to go deeper.  Even if you don’t, I hope you at least take some inspiration regarding interesting ways to solve difficult problems.  Until next time.</p>

        <div class="related-posts-box">
        Related Posts:<ul class="related-posts"><li class="related-posts-item"><a class="related-posts-link" href="/2018/10/10/F-and-Elasticsearch/">F# and Elasticsearch</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2016/12/13/F-and-Dynamic-Time-Warping/">F# and Dynamic Time Warping</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2021/04/23/F-AC3-Solving/">AC-3 Constraint Solving with F#</a></li></ul>        </div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://codesuji.com/2021/08/07/F-String-Search/" data-id="cks1p6xn2004yjkmwpr5iqo40" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Benchmarking/">Benchmarking</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/F/">F#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FSharp/">FSharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Search/">Search</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/11/21/F-RocksDB/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Leveraging RocksDB with F#
        
      </div>
    </a>
  
  
    <a href="/2021/07/28/Data-in-Motion-Drought/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Data in Motion - Drought Map</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/NET-Core/" style="font-size: 17px;">.NET Core</a> <a href="/tags/Accord-NET/" style="font-size: 15px;">Accord.NET</a> <a href="/tags/Algorithms/" style="font-size: 15px;">Algorithms</a> <a href="/tags/Analytics/" style="font-size: 14px;">Analytics</a> <a href="/tags/Audio/" style="font-size: 10px;">Audio</a> <a href="/tags/Benchmarking/" style="font-size: 10px;">Benchmarking</a> <a href="/tags/Chiron/" style="font-size: 10px;">Chiron</a> <a href="/tags/Classification/" style="font-size: 11px;">Classification</a> <a href="/tags/Cognitive-Services/" style="font-size: 11px;">Cognitive Services</a> <a href="/tags/Compiler/" style="font-size: 13px;">Compiler</a> <a href="/tags/Computer-Vision/" style="font-size: 11px;">Computer Vision</a> <a href="/tags/Cordova/" style="font-size: 10px;">Cordova</a> <a href="/tags/DTW/" style="font-size: 14px;">DTW</a> <a href="/tags/Data/" style="font-size: 18px;">Data</a> <a href="/tags/Database/" style="font-size: 13px;">Database</a> <a href="/tags/Decision-Trees/" style="font-size: 11px;">Decision Trees</a> <a href="/tags/Deedle/" style="font-size: 10px;">Deedle</a> <a href="/tags/Delegate/" style="font-size: 10px;">Delegate</a> <a href="/tags/Detection/" style="font-size: 10px;">Detection</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Dynamic-Time-Warping/" style="font-size: 13px;">Dynamic Time Warping</a> <a href="/tags/EEG/" style="font-size: 10px;">EEG</a> <a href="/tags/Edges/" style="font-size: 10px;">Edges</a> <a href="/tags/Education/" style="font-size: 10px;">Education</a> <a href="/tags/Elmish/" style="font-size: 10px;">Elmish</a> <a href="/tags/EmguCV/" style="font-size: 10px;">EmguCV</a> <a href="/tags/Entropy/" style="font-size: 10px;">Entropy</a> <a href="/tags/F/" style="font-size: 20px;">F#</a> <a href="/tags/FParsec/" style="font-size: 12px;">FParsec</a> <a href="/tags/FSAdvent/" style="font-size: 10px;">FSAdvent</a> <a href="/tags/FSharp/" style="font-size: 20px;">FSharp</a> <a href="/tags/Fable/" style="font-size: 10px;">Fable</a> <a href="/tags/Faces/" style="font-size: 11px;">Faces</a> <a href="/tags/Filters/" style="font-size: 10px;">Filters</a> <a href="/tags/Http/" style="font-size: 11px;">Http</a> <a href="/tags/Images/" style="font-size: 12px;">Images</a> <a href="/tags/Ionide/" style="font-size: 10px;">Ionide</a> <a href="/tags/Kaggle/" style="font-size: 12px;">Kaggle</a> <a href="/tags/Keyboard/" style="font-size: 13px;">Keyboard</a> <a href="/tags/Legos/" style="font-size: 11px;">Legos</a> <a href="/tags/Logging/" style="font-size: 10px;">Logging</a> <a href="/tags/MLNet/" style="font-size: 16px;">MLNet</a> <a href="/tags/MSIL/" style="font-size: 12px;">MSIL</a> <a href="/tags/Machine-Learning/" style="font-size: 19px;">Machine Learning</a> <a href="/tags/MathNet/" style="font-size: 10px;">MathNet</a> <a href="/tags/Messaging/" style="font-size: 10px;">Messaging</a> <a href="/tags/Mobile/" style="font-size: 10px;">Mobile</a> <a href="/tags/Mono/" style="font-size: 10px;">Mono</a> <a href="/tags/Morse-Code/" style="font-size: 10px;">Morse Code</a> <a href="/tags/Mqtt/" style="font-size: 12px;">Mqtt</a> <a href="/tags/Nix/" style="font-size: 10px;">Nix</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/Parsing/" style="font-size: 12px;">Parsing</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Presentations/" style="font-size: 10px;">Presentations</a> <a href="/tags/Propagator/" style="font-size: 10px;">Propagator</a> <a href="/tags/Racket/" style="font-size: 10px;">Racket</a> <a href="/tags/Regression/" style="font-size: 10px;">Regression</a> <a href="/tags/Rekognition/" style="font-size: 10px;">Rekognition</a> <a href="/tags/Robotics/" style="font-size: 10px;">Robotics</a> <a href="/tags/Rust/" style="font-size: 10px;">Rust</a> <a href="/tags/STEM/" style="font-size: 11px;">STEM</a> <a href="/tags/Scoring/" style="font-size: 10px;">Scoring</a> <a href="/tags/Search/" style="font-size: 11px;">Search</a> <a href="/tags/Serialization/" style="font-size: 10px;">Serialization</a> <a href="/tags/SignalR/" style="font-size: 10px;">SignalR</a> <a href="/tags/Signals/" style="font-size: 13px;">Signals</a> <a href="/tags/Similarity/" style="font-size: 11px;">Similarity</a> <a href="/tags/Sound/" style="font-size: 10px;">Sound</a> <a href="/tags/Statistics/" style="font-size: 13px;">Statistics</a> <a href="/tags/Text/" style="font-size: 14px;">Text</a> <a href="/tags/Timeseries/" style="font-size: 11px;">Timeseries</a> <a href="/tags/Tips/" style="font-size: 12px;">Tips</a> <a href="/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/tags/Translation/" style="font-size: 10px;">Translation</a> <a href="/tags/Types/" style="font-size: 10px;">Types</a> <a href="/tags/VS-Code/" style="font-size: 10px;">VS Code</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Webapi/" style="font-size: 11px;">Webapi</a> <a href="/tags/admin/" style="font-size: 11px;">admin</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/12/31/lvar/">F# and LVars</a>
          </li>
        
          <li>
            <a href="/2022/08/13/Watc/">Watc</a>
          </li>
        
          <li>
            <a href="/2022/07/24/Data-in-Motion-Earthquakes/">Data in Motion - Earthquakes Map</a>
          </li>
        
          <li>
            <a href="/2022/05/17/Data-in-Motion-Population/">Data in Motion - Population Map</a>
          </li>
        
          <li>
            <a href="/2022/01/30/F-and-MLNet-Anomaly-2/">Taking Stock of More Anomalies with F# and ML.NET</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 codesuji.com<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>