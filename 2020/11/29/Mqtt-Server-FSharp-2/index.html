<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Building an MQTT server in F# - Part 2 | codesuji</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Today I’ll continue the process of building an MQTT server with F#.  The basic networking capabilities I put together last time will be expanded upon to support basic MQTT functionality, specifically">
<meta name="keywords" content="F#,FSharp,Mqtt">
<meta property="og:type" content="article">
<meta property="og:title" content="Building an MQTT server in F# - Part 2">
<meta property="og:url" content="http://codesuji.com/2020/11/29/Mqtt-Server-FSharp-2/index.html">
<meta property="og:site_name" content="codesuji">
<meta property="og:description" content="Today I’ll continue the process of building an MQTT server with F#.  The basic networking capabilities I put together last time will be expanded upon to support basic MQTT functionality, specifically">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-11-30T03:10:08.106Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Building an MQTT server in F# - Part 2">
<meta name="twitter:description" content="Today I’ll continue the process of building an MQTT server with F#.  The basic networking capabilities I put together last time will be expanded upon to support basic MQTT functionality, specifically">
  
    <link rel="alternate" href="/atom.xml" title="codesuji" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89982547-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">codesuji</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://codesuji.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Mqtt-Server-FSharp-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/Mqtt-Server-FSharp-2/" class="article-date">
  <time datetime="2020-11-29T16:03:29.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Building an MQTT server in F# - Part 2
    </h1>
  

 		<span class="post-count">Read Time: 27 minutes</span>
 	  </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Today I’ll continue the process of building an MQTT server with <a href="https://fsharp.org" target="_blank" rel="noopener">F#</a>.  The basic networking capabilities I put together last time will be expanded upon to support basic MQTT functionality, specifically the MQTT Connect message.</p>
<a id="more"></a>
<p>In my <a href="/2020/11/22/Mqtt-Server-FSharp-1/">previous post</a> I setup a simple F# server listening on port 1883, but there was no MQTT functionality.  Today it’s time to start wiring in some real functionality.  Handling a Connect message seems like a logical place to start, so that’s where I’ll begin.  Before getting into the code, I want to take a quick look at the MQTT protocol.  I’m going to gloss over some details, but the <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">MQTT Spec</a> is always there for details if you want to see more.</p>
<p>A quick description of the client and server interaction is in order.  The connection handshake is pretty basic.  The client sends a connect request.  Assuming all is well with the request (supported version, successful authentication, etc), the server then sends a connection ack back to the client.  At this point the connection is established, and the client sends subscribe and publish messages as appropriate.  The server can now send messages to the client that meets it’s subscription criteria.  What do MQTT packets look like?  At a high level, a packet is defined by three components.</p>
<ol>
<li>Fixed Header - A common header across all packet types. Byte 1 contains the packet’s type and standard flags.  Byte 2+ contains the packet’s length, to aid in parsing.</li>
<li>Variable Header - This is a packet-specific metadata header.  As a result, the content and length of this will vary depending on the packet-type in question.</li>
<li>Payload - Here is the actual data.  As a side note, not all packet types have a payload.</li>
</ol>
<p>As eluded to, there are different types of messages that the server supports.  Each packet type having it’s own packet-specific variable header and payload structure.  The ones I’ll concern myself with today are <code>Connect</code> (client -&gt; server message) and <code>ConnAck</code> (server -&gt; client message).  What does this look like when modeling MQTT packets in F#?  The structure of the Connect packet is taken from the spec, and is pretty straight forward.  </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Mqtt Packet type</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PacketType</span> </span>=</span><br><span class="line">  | Connect = <span class="number">1</span>uy</span><br><span class="line">  | ConnAck = <span class="number">2</span>uy</span><br><span class="line">  | Publish = <span class="number">3</span>uy</span><br><span class="line">  | PubAck = <span class="number">4</span>uy</span><br><span class="line">  | PubRec = <span class="number">5</span>uy</span><br><span class="line">  | PubRel = <span class="number">6</span>uy</span><br><span class="line">  | PubComp = <span class="number">7</span>uy</span><br><span class="line">  | Subscribe = <span class="number">8</span>uy</span><br><span class="line">  | SubAck = <span class="number">9</span>uy</span><br><span class="line">  | Unsubscribe = <span class="number">10</span>uy</span><br><span class="line">  | UnsubAck = <span class="number">11</span>uy</span><br><span class="line">  | PingReq = <span class="number">12</span>uy</span><br><span class="line">  | PingResp = <span class="number">13</span>uy</span><br><span class="line">  | Disconnect = <span class="number">14</span>uy</span><br><span class="line">  | Reserved = <span class="number">15</span>uy</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Connect packet - Fixed header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">RequestConnectFixedHeader</span> </span>=</span><br><span class="line">  &#123; PacketType: PacketType</span><br><span class="line">    RemainingLength: int</span><br><span class="line">    Size: int &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Connect packet - Flags</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ConnectFlags</span> </span>=</span><br><span class="line">  &#123; UserName: bool</span><br><span class="line">    Password: bool</span><br><span class="line">    WillRetain: bool</span><br><span class="line">    WillQoS: int</span><br><span class="line">    WillFlag: bool</span><br><span class="line">    CleanSession: bool</span><br><span class="line">    Reserved: bool &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Connect packet - Variable header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">RequestConnectVariableHeader</span> </span>=</span><br><span class="line">  &#123; Name: string</span><br><span class="line">    Level: int</span><br><span class="line">    Flags: ConnectFlags</span><br><span class="line">    KeepAlive: int</span><br><span class="line">    Size: int &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Connect packet - Payload</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">RequestConnectPayload</span> </span>=</span><br><span class="line">  &#123; ClientIdentifier: string option</span><br><span class="line">    WillTopic: string option</span><br><span class="line">    WillMessage: byte [] option</span><br><span class="line">    UserName: string option</span><br><span class="line">    Password: string option &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Connect packet</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">RequestConnectPacket</span> </span>=</span><br><span class="line">  &#123; FixedHeader: RequestConnectFixedHeader</span><br><span class="line">    VariableHeader: RequestConnectVariableHeader</span><br><span class="line">    Payload: RequestConnectPayload &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Request packet</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">RequestPacket</span> </span>=</span><br><span class="line">  | Connect <span class="keyword">of</span> RequestConnectPacket</span><br><span class="line">  | Empty</span><br></pre></td></tr></table></figure>
<p>Now that the Connect packet is defined, it’s time to parse the byte stream.  I handle this in two steps.  First, determine what the packet type is by peeking at the first byte.  Second, I pass the stream to the appropriate parser based on the type.  The packet type is defined in the top half of the first byte of the MQTT packet.  So I need to bitshift and then match to determine the packet type.  Once I have that I parse a packet.  Successful parsing results in a RequestPacket option, otherwise I just return None.  The option type allows the calling control flow to easily process data based on parsing results.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Given a byte (first byte from fixed header), determine the packet type</span></span><br><span class="line"><span class="keyword">let</span> getPacketType (headerByte: byte) :PacketType =</span><br><span class="line">  <span class="keyword">match</span> headerByte &gt;&gt;&gt; <span class="number">4</span> <span class="keyword">with</span></span><br><span class="line">  | <span class="number">1</span>uy -&gt; PacketType.Connect</span><br><span class="line">  | <span class="number">2</span>uy -&gt; PacketType.ConnAck</span><br><span class="line">  | <span class="number">3</span>uy -&gt; PacketType.Publish</span><br><span class="line">  | <span class="number">4</span>uy -&gt; PacketType.PubAck</span><br><span class="line">  | <span class="number">5</span>uy -&gt; PacketType.PubRec</span><br><span class="line">  | <span class="number">6</span>uy -&gt; PacketType.PubRel</span><br><span class="line">  | <span class="number">7</span>uy -&gt; PacketType.PubComp</span><br><span class="line">  | <span class="number">8</span>uy -&gt; PacketType.Subscribe</span><br><span class="line">  | <span class="number">9</span>uy -&gt; PacketType.SubAck</span><br><span class="line">  | <span class="number">10</span>uy -&gt; PacketType.Unsubscribe</span><br><span class="line">  | <span class="number">11</span>uy -&gt; PacketType.UnsubAck</span><br><span class="line">  | <span class="number">12</span>uy -&gt; PacketType.PingReq</span><br><span class="line">  | <span class="number">13</span>uy -&gt; PacketType.PingResp</span><br><span class="line">  | <span class="number">14</span>uy -&gt; PacketType.Disconnect</span><br><span class="line">  | <span class="number">15</span>uy -&gt; PacketType.Reserved</span><br><span class="line">  | _ -&gt; PacketType.Reserved</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract a packet from the buffer</span></span><br><span class="line"><span class="keyword">let</span> parseBufferSegment (buffer: ReadOnlyMemory&lt;byte&gt;) :RequestPacket option =</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">    <span class="keyword">let</span> buffer' = buffer.Span</span><br><span class="line">    <span class="keyword">let</span> packetType = getPacketType buffer'.[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> packetType <span class="keyword">with</span></span><br><span class="line">    | PacketType.Connect -&gt; parseRequestConnectPacket buffer'</span><br><span class="line">    | _ -&gt; printfn <span class="string">"ERROR: Unsupported packet type: %A"</span> packetType</span><br><span class="line">           None    </span><br><span class="line">  <span class="keyword">with</span></span><br><span class="line">  | :? Exception <span class="keyword">as</span> ex -&gt; printfn <span class="string">"ERROR: Parsing packet: %s"</span> ex.Message</span><br><span class="line">                          None</span><br></pre></td></tr></table></figure>
<p>There are a couple ways I could’ve handled the parsing.  My approach is to leverage the Span provided to the parsing function.  This means I need to track current position as I parse byte by byte through the packet.  There is also a common pattern I’ll follow. It is often, but not always, the case that the variable header parsing will depending on values in the fixed header, and the payload will depend on both headers.  I’ll use a pattern of always passing in the previously parsed headers as well as current index, in case the current parsing step requires data.  This means sometimes passing things I don’t need, but it reduces mental overhead to just always pass along all headers.  This is something that often gets overlooked in design.  Unless you need to squeeze every ounce of performance out of a system, designing for easing mental load is an important goal to strive for. </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Parse buffer for a Connect packet</span></span><br><span class="line"><span class="keyword">let</span> parseRequestConnectPacket (buffer: ReadOnlySpan&lt;byte&gt;) :RequestPacket option =</span><br><span class="line">  <span class="keyword">let</span> position = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> (fixedHeader, position) = parseRequestConnectFixedHeader buffer</span><br><span class="line">  <span class="keyword">let</span> (variableHeader, position) = parseRequestConnectVariableHeader buffer fixedHeader position</span><br><span class="line">  <span class="keyword">let</span> (payload, position) = parseRequestConnectPayload buffer fixedHeader variableHeader position</span><br><span class="line"></span><br><span class="line">  Some(RequestPacket.Connect</span><br><span class="line">    &#123; RequestConnectPacket.FixedHeader = fixedHeader</span><br><span class="line">      VariableHeader = variableHeader</span><br><span class="line">      Payload = payload &#125;)</span><br></pre></td></tr></table></figure>
<p>This has been mostly control flow until now.  Now it’s time to dig into the parsing.  First is the fixed header.  Based on the spec it is at least two bytes.  The first byte contains the packet type, and no flags.  The rest of the byte(s) are the remaining length of the packet.  To accommodate variable length packets (and save space) the length is encoded in a variable length field.  When in F# I often find it tempting to rewrite algorithms in a more functional style.  But there also isn’t a reason to make it harder for myself than I need to.  Direct translation of the provided spec is the easiest path forward.  Things like <code>mutuable</code> are a code smell.  In this case it’s a reasonable trade-off to verify that I’m matching the spec’s algorithm.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Extract the packet's remaining length for the fixed header</span></span><br><span class="line"><span class="comment">/// start - Start of length</span></span><br><span class="line"><span class="comment">/// Returns: length, index immediately following length</span></span><br><span class="line"><span class="keyword">let</span> getPacketRemainingLength (buffer: ReadOnlySpan&lt;byte&gt;) (start: int) :(int * int) =</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> position = start</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> multiplier = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> value = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> keepGoing = <span class="keyword">true</span></span><br><span class="line">  <span class="keyword">while</span> keepGoing <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> encodedByte = int buffer.[position] </span><br><span class="line">    value &lt;- value + (encodedByte &amp;&amp;&amp; <span class="number">127</span>) * multiplier</span><br><span class="line">    multiplier &lt;- multiplier * <span class="number">128</span></span><br><span class="line">    <span class="keyword">if</span> (multiplier &gt; <span class="number">128</span> * <span class="number">128</span> * <span class="number">128</span>) <span class="keyword">then</span> raise (Exception <span class="string">"Malformed remaining length"</span>)</span><br><span class="line">    keepGoing &lt;- encodedByte &amp;&amp;&amp; <span class="number">128</span> &lt;&gt; <span class="number">0</span></span><br><span class="line">    position &lt;- position + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  (value, position)</span><br><span class="line"></span><br><span class="line">  <span class="comment">(* Spec reference</span></span><br><span class="line"><span class="comment">    multiplier = 1</span></span><br><span class="line"><span class="comment">    value = 0</span></span><br><span class="line"><span class="comment">    do</span></span><br><span class="line"><span class="comment">      encodedByte = 'next byte from stream'</span></span><br><span class="line"><span class="comment">      value += (encodedByte AND 127) * multiplier</span></span><br><span class="line"><span class="comment">      multiplier *= 128</span></span><br><span class="line"><span class="comment">      if (multiplier &gt; 128*128*128)</span></span><br><span class="line"><span class="comment">         throw Error(Malformed Remaining Length)</span></span><br><span class="line"><span class="comment">    while ((encodedByte AND 128) != 0) *)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract fixed header (Connect) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parseRequestConnectFixedHeader (buffer: ReadOnlySpan&lt;byte&gt;) :(RequestConnectFixedHeader * int) =</span><br><span class="line">  <span class="keyword">let</span> position = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> packetType = getPacketType buffer.[position]</span><br><span class="line">  <span class="keyword">let</span> (remainingLength, position') = getPacketRemainingLength buffer (position + <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  (&#123; RequestConnectFixedHeader.PacketType = packetType</span><br><span class="line">     RemainingLength = remainingLength</span><br><span class="line">     Size = position' &#125;,</span><br><span class="line">   position')</span><br></pre></td></tr></table></figure>
<p>The variable header contains a bit more parsing to deal with.  Specifically it contains four fields: Protocol Name, Level, Flags, and KeepAlive.  These are mostly boolean flags that I extract with bitshifts and ANDing.  Level is an int for supported MQTT version.  The Name field is a string.  The MQTT protocol follows a common pattern when storing strings; a two byte length field followed by the UTF8 encoded string of the specified length.  This shows up a lot throughout the parsing process.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Extract variable header (Connect) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parseRequestConnectVariableHeader (buffer: ReadOnlySpan&lt;byte&gt;)</span><br><span class="line">                                      (fixedHeader: RequestConnectFixedHeader)</span><br><span class="line">                                      (position: int)</span><br><span class="line">                                      : (RequestConnectVariableHeader * int) =</span><br><span class="line">  <span class="keyword">let</span> startPosition = position</span><br><span class="line"></span><br><span class="line">  <span class="comment">// name</span></span><br><span class="line">  <span class="keyword">let</span> nameLength = twoBytesToInt (buffer.Slice(position, <span class="number">2</span>))</span><br><span class="line">  <span class="keyword">let</span> name = Encoding.UTF8.GetString(buffer.Slice(position + <span class="number">2</span>, nameLength))</span><br><span class="line">  <span class="keyword">let</span> position = position + <span class="number">2</span> + nameLength</span><br><span class="line"></span><br><span class="line">  <span class="comment">// level</span></span><br><span class="line">  <span class="keyword">let</span> level = int buffer.[position]</span><br><span class="line">  <span class="keyword">let</span> position = position + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// flags</span></span><br><span class="line">  <span class="keyword">let</span> flags = buffer.[position]</span><br><span class="line">  <span class="keyword">let</span> position = position + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> (userName, password, willRetain, willQoS, willFlag, cleanSession, reserved) =</span><br><span class="line">    (flags &amp;&amp;&amp; <span class="number">128</span>uy &lt;&gt; <span class="number">0</span>uy,</span><br><span class="line">     flags &amp;&amp;&amp; <span class="number">64</span>uy &lt;&gt; <span class="number">0</span>uy,</span><br><span class="line">     flags &amp;&amp;&amp; <span class="number">32</span>uy &lt;&gt; <span class="number">0</span>uy,</span><br><span class="line">     flags &amp;&amp;&amp; <span class="number">24</span>uy &gt;&gt;&gt; <span class="number">3</span>,</span><br><span class="line">     flags &amp;&amp;&amp; <span class="number">4</span>uy &lt;&gt; <span class="number">0</span>uy,</span><br><span class="line">     flags &amp;&amp;&amp; <span class="number">2</span>uy &lt;&gt; <span class="number">0</span>uy,</span><br><span class="line">     flags &amp;&amp;&amp; <span class="number">1</span>uy &lt;&gt; <span class="number">0</span>uy)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> connectFlags =</span><br><span class="line">    &#123; ConnectFlags.UserName = userName</span><br><span class="line">      Password = password</span><br><span class="line">      WillRetain = willRetain</span><br><span class="line">      WillQoS = int willQoS</span><br><span class="line">      WillFlag = willFlag</span><br><span class="line">      CleanSession = cleanSession</span><br><span class="line">      Reserved = reserved &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keepalive</span></span><br><span class="line">  <span class="keyword">let</span> keepAlive = twoBytesToInt (buffer.Slice(position, <span class="number">2</span>))</span><br><span class="line">  <span class="keyword">let</span> position = position + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  (&#123; RequestConnectVariableHeader.Name = name</span><br><span class="line">     Level = level</span><br><span class="line">     Flags = connectFlags</span><br><span class="line">     KeepAlive = keepAlive</span><br><span class="line">     Size = position - startPosition &#125;,</span><br><span class="line">   position)</span><br></pre></td></tr></table></figure>
<p>Finally, the payload.  For a connect packet, what is in the payload is determined by the flags in the variable header.  So here is mostly conditional extraction of values, which means most of the payload values are Option types.  As an example, if the <code>UserName</code> flag was set in the header, then a UserName is expected in the payload. </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Extract a byte array from a header or payload.</span></span><br><span class="line"><span class="comment">/// Requires the data is in the format: length (2bytes) value (length bytes)</span></span><br><span class="line"><span class="comment">/// Example: [ 0 5 97 98 99 100 101 ]</span></span><br><span class="line"><span class="keyword">let</span> extractBytes (buffer: ReadOnlySpan&lt;byte&gt;) (position: int): (byte [] * int) =</span><br><span class="line">  <span class="keyword">let</span> length = twoBytesToInt (buffer.Slice(position, <span class="number">2</span>))</span><br><span class="line">  <span class="keyword">let</span> value = buffer.Slice(position + <span class="number">2</span>, length).ToArray()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> position = position + <span class="number">2</span> + length</span><br><span class="line">  (value, position)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract bytes if the flag is true</span></span><br><span class="line"><span class="keyword">let</span> extractConditionalBytes (buffer: ReadOnlySpan&lt;byte&gt;) (position: int) (flag: bool): (byte [] option * int) =</span><br><span class="line">  <span class="keyword">if</span> flag <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">let</span> (value, position) = extractBytes buffer position</span><br><span class="line">    (Some value, position)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    (None, position)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract payload (Connect) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parseRequestConnectPayload (buffer: ReadOnlySpan&lt;byte&gt;)</span><br><span class="line">                               (fixedHeader: RequestConnectFixedHeader)</span><br><span class="line">                               (variableHeader: RequestConnectVariableHeader)</span><br><span class="line">                               (position: int)</span><br><span class="line">                               : (RequestConnectPayload * int) =</span><br><span class="line">  <span class="comment">// Client Identifier</span></span><br><span class="line">  <span class="keyword">let</span> (clientIdentifier, position) = extractString buffer position</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get optional data from client if provided</span></span><br><span class="line">  <span class="keyword">let</span> (willTopic, position) = extractConditionalString buffer position variableHeader.Flags.WillFlag</span><br><span class="line">  <span class="keyword">let</span> (willMessage, position) = extractConditionalBytes buffer position variableHeader.Flags.WillFlag</span><br><span class="line">  <span class="keyword">let</span> (userName, position) = extractConditionalString buffer position variableHeader.Flags.UserName</span><br><span class="line">  <span class="keyword">let</span> (password, position) = extractConditionalString buffer position variableHeader.Flags.Password</span><br><span class="line"></span><br><span class="line">  (&#123; ClientIdentifier = Some clientIdentifier</span><br><span class="line">     WillTopic = willTopic</span><br><span class="line">     WillMessage = willMessage</span><br><span class="line">     UserName = userName</span><br><span class="line">     Password = password &#125;,</span><br><span class="line">   position)</span><br></pre></td></tr></table></figure>
<p>Once a Connect packet is parsed, it needs to be processed.  Like the parsing code, right now the example only includes Connect. This will be expanded over future posts.  The control flow is again just matching against type. Per the spec, I disconnect from the client if I get invalid data.  This could either be due to failed parsing, or just an unsupported type. </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Process an mqtt request packet</span></span><br><span class="line"><span class="keyword">let</span> processPacket (state: StateManager) (context: ConnectionContext) (packet: RequestPacket option) =</span><br><span class="line">  <span class="keyword">match</span> packet <span class="keyword">with</span></span><br><span class="line">  | Some(RequestPacket.Connect (p)) -&gt; processConnect state context p</span><br><span class="line">  | None -&gt; </span><br><span class="line">      printfn <span class="string">"ERROR: Invalid packet data. Disconnecting..."</span></span><br><span class="line">      processDisconnect state context</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Disconnect client</span></span><br><span class="line"><span class="keyword">let</span> disconnectClient (state: StateManager) (context: ConnectionContext) =</span><br><span class="line">  processDisconnect state context</span><br></pre></td></tr></table></figure>
<p>Before I can fully process a Connect packet, I need to provide some supporting functions and types.  Specifically I need to define a response packet for the client in the way of <code>ConnAck</code>.  Like the request packets, it is compromised of a fixed header and variable header (ConnAck doesn’t have a payload, but many response packets do).  Unlike request packets, I need to handle serialization for when sending to the client.  This is easy enough to accomplish with a <code>Serialize</code> function attached to the type.  This a direct serialization to bytes.  Serialization can get a little hairy, but really at this point the toughest parts to deal with have been the byte parsing and the serialization.  Thankfully everything else has been the “easy stuff”. </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ConnAck response packet - Fixed header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ConnAckFixedHeader</span> </span>=</span><br><span class="line">  &#123; PacketType: PacketType</span><br><span class="line">    RemainingLength: int &#125;</span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    [| [| byte __.PacketType &lt;&lt;&lt; <span class="number">4</span> |]</span><br><span class="line">       (encodePacketRemainingLength __.RemainingLength) |]</span><br><span class="line">    |&gt; Array.concat</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ConnAck flags</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ConnAckFlags</span> </span>=</span><br><span class="line">  &#123; SessionPresent: bool &#125;</span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    <span class="number">0</span>uy &amp;&amp;&amp; <span class="keyword">if</span> __.SessionPresent <span class="keyword">then</span> <span class="number">1</span>uy <span class="keyword">else</span> <span class="number">0</span>uy</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ConnAck response packet - Variable header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ConnAckVariableHeader</span> </span>=</span><br><span class="line">  &#123; Flags: ConnAckFlags</span><br><span class="line">    ReturnCode: ConnAckReturnCode &#125;</span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    [| __.Flags.Serialize()</span><br><span class="line">       byte __.ReturnCode |]</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ConnAck response packet</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ConnAckResponsePacket</span> </span>=</span><br><span class="line">  &#123; FixedHeader: ConnAckFixedHeader</span><br><span class="line">    VariableHeader: ConnAckVariableHeader &#125;</span><br><span class="line">  <span class="keyword">interface</span> IResponsePacket <span class="keyword">with</span></span><br><span class="line">    <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">      [| __.FixedHeader.Serialize()</span><br><span class="line">         __.VariableHeader.Serialize() |]</span><br><span class="line">      |&gt; Array.concat</span><br></pre></td></tr></table></figure>
<p>With that out of the way, I can look at the Connect packet processing.  The connection handshake is straight-forward. I can perform client authentication and prepare the ConnAck packet.  Once complete, the final steps are sending the response back to the client and updating system state.  That is handled with the <code>state.Post</code> call.  I’m going to hand wave over this part for now since the underlying implementation involved.  Just trust me for now that the serialized packet will get back to the client.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Process a Connection packet</span></span><br><span class="line"><span class="keyword">let</span> processConnect (state: StateManager) (context: ConnectionContext) (packet: RequestConnectPacket): ProcessResult option =</span><br><span class="line">  <span class="keyword">let</span> permitConnect =</span><br><span class="line">    <span class="keyword">if</span> requireAuthentication</span><br><span class="line">    <span class="keyword">then</span> authenticate packet.Payload.UserName packet.Payload.Password</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> permitConnect <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">let</span> variableHeader =</span><br><span class="line">      &#123; ConnAckVariableHeader.Flags = &#123; ConnAckFlags.SessionPresent = <span class="keyword">true</span> &#125;</span><br><span class="line">        ReturnCode = ConnAckReturnCode.Accepted &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> variableHeader' = variableHeader.Serialize()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fixedHeader =</span><br><span class="line">      &#123; ConnAckFixedHeader.PacketType = PacketType.ConnAck</span><br><span class="line">        RemainingLength = variableHeader'.Length &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> connAckPacket =</span><br><span class="line">      &#123; ConnAckResponsePacket.FixedHeader = fixedHeader</span><br><span class="line">        VariableHeader = variableHeader &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connected</span></span><br><span class="line">    <span class="keyword">let</span> message = serializeResponsePacket connAckPacket</span><br><span class="line">    state.Post(StateMessage.Connect(context, message))</span><br><span class="line"></span><br><span class="line">    None</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    Some ProcessResult.Disconnect</span><br></pre></td></tr></table></figure>
<p>At this point I’ve covered parsing of a Connect packet as well as crafting a response packet.  After working with the byte-level details, I need to tie things all together. There is a small detail I glossed over when discussing the original handler from the last post.  There are a couple dynamics regarding packets and the provided buffer data.  MQTT is often used for lots of short messages, but it is entirely within the spec that they could also be longer than the Kestrel-provided segment length.  So although Kestrel handles a lot of the networking dynamics I’m not completely absolved of dealing with at least some of it.  I need a way to deal with multiple packets in a memory segment or a packet being split across segments.  There are are couple ways to handle this.  My preference is to keep the parsing code as clean as possible, which means I don’t want to add the complexity of multiple segments there.  My approach is to write my own segment buffer abstraction, called <code>SegmentBuffer</code>.  This will store multiple segments as the arrive and I’ll write my own <code>Item</code>, <code>Slice</code>, and <code>Length</code> methods to hit the common use-cases.  This abstraction incurs a small performance cost, but makes the parsing so much easier to process.</p>
<p>With that out of the way I need to rework the handler by removing the echo placeholder.  I modify the handler to aggregate the buffer to my abstraction.  Once in a manageable structure, I can do a quick peek at the next packet.  Now I can grab packet-length blocks from the buffer and pass them to the parser.  Doing it this way makes the parsing easier.  Considering parsing is often the messy part, it pays to simplify it as much as possible.  Once parsed, I pass the packet to be processed.  This is done as long as their are complete packets in the SegmentBuffer to be processed.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Mqtt handler - using segmentbuffer</span></span><br><span class="line"><span class="keyword">override</span> __.OnConnectedAsync(connection: ConnectionContext) =</span><br><span class="line">  printfn <span class="string">"Client connected"</span></span><br><span class="line">  <span class="keyword">let</span> segmentBuffer = SegmentBuffer()</span><br><span class="line"></span><br><span class="line">  async &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mutable</span> clientConnected = <span class="keyword">true</span></span><br><span class="line">      <span class="keyword">while</span> clientConnected <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">let!</span> result = Async.AwaitTask(connection.Transport.Input.ReadAsync().AsTask())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.IsCanceled || result.IsCompleted) <span class="keyword">then</span></span><br><span class="line">          clientConnected &lt;- <span class="keyword">false</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// Append all segments from the client buffer to the larger segmentbuffer</span></span><br><span class="line">          <span class="keyword">let</span> buffer = result.Buffer</span><br><span class="line">          <span class="keyword">let</span> <span class="keyword">mutable</span> iter = buffer.GetEnumerator()</span><br><span class="line">          <span class="keyword">let</span> <span class="keyword">mutable</span> continueClientBuffer = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> continueClientBuffer <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">let</span> segment = iter.Current</span><br><span class="line">            segmentBuffer.Append segment</span><br><span class="line">            continueClientBuffer &lt;- iter.MoveNext()</span><br><span class="line"></span><br><span class="line">          connection.Transport.Input.AdvanceTo(buffer.End)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Process the segmentBuffer</span></span><br><span class="line">          <span class="keyword">let</span> <span class="keyword">mutable</span> continueSegmentBuffer = <span class="keyword">true</span></span><br><span class="line">          <span class="keyword">while</span> continueSegmentBuffer <span class="keyword">do</span></span><br><span class="line">              <span class="keyword">let</span> peekResults = peekPacketLength segmentBuffer </span><br><span class="line">              <span class="keyword">match</span> peekResults <span class="keyword">with</span></span><br><span class="line">              | Some (packetLength) -&gt;</span><br><span class="line">                  <span class="comment">// Parse and process packet</span></span><br><span class="line">                  <span class="keyword">let</span> result =</span><br><span class="line">                    packetLength</span><br><span class="line">                    |&gt; segmentBuffer.ConsumeSlice</span><br><span class="line">                    |&gt; tap printPacket</span><br><span class="line">                    |&gt; parseBufferSegment</span><br><span class="line">                    |&gt; processPacket state connection</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">match</span> result <span class="keyword">with</span></span><br><span class="line">                  | Some (MqttType.ProcessResult.Disconnect) -&gt; continueSegmentBuffer &lt;- <span class="keyword">false</span></span><br><span class="line">                  | _ -&gt; ()</span><br><span class="line">              | None -&gt; continueSegmentBuffer &lt;- <span class="keyword">false</span> <span class="comment">// Don't have entire packet</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Cleanup client connection</span></span><br><span class="line">      disconnectClient state connection |&gt; ignore</span><br><span class="line">    <span class="keyword">with</span></span><br><span class="line">    | ex -&gt; printfn <span class="string">"ERROR: %A"</span> ex</span><br><span class="line">  &#125;</span><br><span class="line">  |&gt; Async.StartAsTask :&gt; Task</span><br></pre></td></tr></table></figure>
<p>In the echo server example client communication was simple; read from client, write to client.  As expected, MQTT is more involved.  The server must maintain the internal state to support multiple clients, their topic subscriptions, as well as the ability to publish messages to clients based on their subscriptions.  For this I’ll use a central control function to manage these interactions, which I’ll call a StateManager.  It’s interface will be supplied by a MailboxProcessor.  This provides me asyncronous processing capability without having to worry about data or lock contention.  From the main control interface, I’ll create a function for each supported MQTT message type.  This allows me to centralize all state management as well as handling proper message sending to all clients.  Taking a deeper look at state management requirements, I need a way to track connected clients and their subscriptions.  I also need to track active messages (messages that are published, and possibly retained).  This domain modeling is simple enough to do with F# records.  Additionally, I have moved the <code>context.Transport.Output.WriteAsync()</code> functionality into the state manager, specifically a <code>writeMessage</code> function.  I typically like to keep the read and write to clients together in the main handler, but it just isn’t a reasonable option in this case.  Interacting with multiple clients based on a single client’s message requires this to be buried a layer deeper in the code.  But at least I can keep all client interactions in a single place.  This ends up being an overall win, and the code is still reasonably clean.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MqttState</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> Microsoft.AspNetCore.Connections</span><br><span class="line"><span class="keyword">open</span> MqttType</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Connected client metadata</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ConnectedClient</span> </span>=</span><br><span class="line">  &#123; ConnectionId: string</span><br><span class="line">    Context: ConnectionContext</span><br><span class="line">    Subscriptions: TopicFilter array &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Client reference object </span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ActiveMessageClient</span> </span>=</span><br><span class="line">  &#123; ClientId: string;</span><br><span class="line">    Qos: byte &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Cached messages</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ActiveMessage</span> </span>=</span><br><span class="line">  &#123; Message: byte []</span><br><span class="line">    Retained: bool</span><br><span class="line">    Clients: ActiveMessageClient list &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// MQTT server state data, including connected clients and message</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">MqttState</span> </span>=</span><br><span class="line">  &#123; ConnectedClients: Map&lt;string, ConnectedClient&gt;</span><br><span class="line">    ActiveMessages: ActiveMessage list &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Initial MQTT server state</span></span><br><span class="line"><span class="keyword">let</span> emptyMqttState =</span><br><span class="line">  &#123; MqttState.ConnectedClients = Map.empty</span><br><span class="line">    ActiveMessages = [] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Supported messages that update server state</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">StateMessage</span> </span>=</span><br><span class="line">  | Connect <span class="keyword">of</span> (ConnectionContext * byte [])</span><br><span class="line">  | Disconnect <span class="keyword">of</span> ConnectionContext</span><br><span class="line"></span><br><span class="line"><span class="comment">/// MQTT Server state object</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">StateManager</span> </span>= MailboxProcessor&lt;StateMessage&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Write message to specific client context</span></span><br><span class="line"><span class="keyword">let</span> writeMessage (connection: ConnectionContext) (message: byte []) =</span><br><span class="line">  async &#123;</span><br><span class="line">    printfn <span class="string">"Sending: %A"</span> (message)</span><br><span class="line">    <span class="keyword">let</span> message' = System.ReadOnlyMemory&lt;byte&gt;(message)</span><br><span class="line">    <span class="keyword">let!</span> result = Async.AwaitTask(connection.Transport.Output.WriteAsync(message').AsTask())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> result.IsCanceled <span class="keyword">then</span> <span class="keyword">false</span> <span class="comment">// Operation cancelled</span></span><br><span class="line">      <span class="keyword">elif</span> result.IsCompleted <span class="keyword">then</span> <span class="keyword">false</span> <span class="comment">// Client connection closed</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">true</span> <span class="comment">// Completed successfully</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Interface to state manager</span></span><br><span class="line"><span class="keyword">let</span> stateManager () =</span><br><span class="line">  <span class="keyword">fun</span> (inbox: StateManager) -&gt;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> loop s =</span><br><span class="line">      async &#123;</span><br><span class="line">        <span class="keyword">let!</span> (msg: StateMessage) = inbox.Receive()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let!</span> s' =</span><br><span class="line">          <span class="keyword">match</span> msg <span class="keyword">with</span></span><br><span class="line">          | Connect (connection, message) -&gt; stateConnect s connection message</span><br><span class="line">          | Disconnect (connection) -&gt; stateDisconnect s connection</span><br><span class="line">        <span class="comment">// printfn "state: %A" s'</span></span><br><span class="line">        showState s'</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return!</span> loop s'</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    loop emptyMqttState</span><br></pre></td></tr></table></figure>
<p>Now that the supporting structure is implemented, I can directly address how I handle connects.  When a Connect message is processed, it is ultimately ends up in the <code>stateConnect</code> function of the StateManager (remember the hand-waving from earlier?).  The server needs to keep track of clients. so a <code>ConnectedClient</code> record is created and added to the client tracking map.  It also sends a <code>ConnAck</code> message back to client, letting them know they are connected.  This completes the connection handshake.  I’m including the client <code>Disconnect</code> processing as well.  This is partially because it is a nice symmetry with Connect, but also it gets woven throughout the code to handle bad messages (through parsing and processing).  The typical response to bad things in MQTT is just disconnect the client, so it is just natural to include it immediately.  Fwiw, there are specifically client Disconnect message as well.  So, here the opposite of Connect happens, remove the client from the <code>ConnectedClients</code> map.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Handle client connect</span></span><br><span class="line"><span class="keyword">let</span> stateConnect (state: MqttState) (connection: ConnectionContext) (message: byte []) =</span><br><span class="line">  async &#123;</span><br><span class="line">    <span class="keyword">let!</span> success = writeMessage connection message</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update state</span></span><br><span class="line">    <span class="keyword">let</span> client =</span><br><span class="line">      &#123; ConnectedClient.ConnectionId = connection.ConnectionId</span><br><span class="line">        Context = connection</span><br><span class="line">        Subscriptions = [||] &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> client' = Map.add connection.ConnectionId client state.ConnectedClients</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; state <span class="keyword">with</span> ConnectedClients = client' &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Handle client disconnect</span></span><br><span class="line"><span class="keyword">let</span> stateDisconnect (state: MqttState) (connection: ConnectionContext) =</span><br><span class="line">  <span class="keyword">let</span> clientId = connection.ConnectionId</span><br><span class="line">  async &#123;</span><br><span class="line">    <span class="comment">// Kill client connection</span></span><br><span class="line">    connection.Abort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> clients = Map.remove clientId state.ConnectedClients</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> messages =</span><br><span class="line">      state.ActiveMessages</span><br><span class="line">      |&gt; List.map (<span class="keyword">fun</span> m -&gt;</span><br><span class="line">           <span class="keyword">let</span> c' =</span><br><span class="line">             m.Clients</span><br><span class="line">             |&gt; List.filter (<span class="keyword">fun</span> c -&gt; c.ClientId &lt;&gt; clientId)</span><br><span class="line"></span><br><span class="line">           &#123; m <span class="keyword">with</span> Clients = c' &#125;)</span><br><span class="line">      |&gt; List.filter (<span class="keyword">fun</span> m -&gt; m.Clients.Length &lt;&gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; state <span class="keyword">with</span></span><br><span class="line">               ConnectedClients = clients</span><br><span class="line">               ActiveMessages = messages &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Once the state manager is fully defined, it gets added to the <code>MqttConnectionHandler</code> class.  You may have noticed earlier, it gets passed into the packet processing function.  This singleton is what allows me to have a shared server state that can be easily managed.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// mqtt server state</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> <span class="keyword">mutable</span> state = MailboxProcessor.Start(stateManager ())</span><br></pre></td></tr></table></figure>
<p>At this point the server can handle a <code>Connect</code> message from the client. This includes adding the client to it’s internal state handling as well as responding with the proper <code>ConnAck</code> message.  Now is a good time to see this in action.  From the server side, I can see the client network connection as well as reception and consumption of it’s MQTT Connect packet.  Upon proper connection it sends a ConnAck back to the client.  From the client side, it sends the Connect and receives a ConnAck. Great! This is the short-term goal, and I’d say mission accomplished.  This is also a good time to point out that my test client is prepped for a fully functional interaction, so after connection it attempts to subscribe to a topic.  Obviously this hasn’t been implemented yet, so the server catches the unsupported packet error and disconnects the client.  I guess I know what I need to work on next.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Server</span><br><span class="line">$ dotnet run</span><br><span class="line">Content root path: /home/codesuji/projects/mqtt-server/src</span><br><span class="line">Now listening on: http://localhost:1883</span><br><span class="line">Application started. Press Ctrl+C to shut down.</span><br><span class="line">Client connected</span><br><span class="line">PacketLength: Some 60</span><br><span class="line">Packet (60): Length:  60 Data: 10 3A 00 04 4D 51 54 54 04 C6 00 64 00 0F 6D 71 74 74 6A 73 5F 64 37 39 66 66 66 31 65 00 06 69 2D 64 69 65 64 00 07 63 6C 69 65 6E 74 41 00 05 75 73 65 72 31 00 05 70 61 73 73 31</span><br><span class="line">PacketType: Connect</span><br><span class="line">Sending: [|32uy; 2uy; 0uy; 0uy|]</span><br><span class="line">State:</span><br><span class="line">  Clients:</span><br><span class="line">    0HM4JKJV9HHNF Subscriptions: </span><br><span class="line">  Messages:</span><br><span class="line">PacketLength: Some 16</span><br><span class="line">Packet (16): Length:  16 Data: 82 0E 1D D7 00 09 74 6F 70 69 63 2D 66 6F 6F 00</span><br><span class="line">PacketType: Subscribe</span><br><span class="line">ERROR: Unsupported packet type: Subscribe</span><br><span class="line">ERROR: Invalid packet data. Disconnecting...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Client </span><br><span class="line">$ node mqttclient.js </span><br><span class="line">Connected Packet &#123;</span><br><span class="line">  cmd: &apos;connack&apos;,</span><br><span class="line">  retain: false,</span><br><span class="line">  qos: 0,</span><br><span class="line">  dup: false,</span><br><span class="line">  length: 2,</span><br><span class="line">  topic: null,</span><br><span class="line">  payload: null,</span><br><span class="line">  sessionPresent: false,</span><br><span class="line">  returnCode: 0</span><br><span class="line">&#125;</span><br><span class="line">Connection closed.</span><br></pre></td></tr></table></figure>
<p>At this point I have the server supporting very basic MQTT functionality, specifically Connect messages.  As is often the case, the beginning of a project often includes a lot of setup and yak shaving before I can get to the ultimate, or even preliminary, goal.  But this process is also informative.  It is a view into how system state and basic MQTT types can be modeled in F#.  I’m probably a little biased, but F#’s ability to model proper state and structure is a definite asset, and makes refactoring through this process a breeze.  With my goal met, this is a good stopping point.  I hope you found this post informative.  Next time I’ll venture further into the MQTT spec and tackle Subcribe and Publish.</p>

        <div class="related-posts-box">
        Related Posts:<ul class="related-posts"><li class="related-posts-item"><a class="related-posts-link" href="/2020/12/12/Mqtt-Server-FSharp-3/">Building an MQTT server in F# - Part 3</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2020/11/22/Mqtt-Server-FSharp-1/">Building an MQTT server in F# - Part 1</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2017/03/04/bf-compiler-part3-compiler/">BF Compiler Part 3 - Compiler</a></li></ul>        </div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://codesuji.com/2020/11/29/Mqtt-Server-FSharp-2/" data-id="cks1p6xos00c5jkmweyqrz2tz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/F/">F#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FSharp/">FSharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mqtt/">Mqtt</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/12/Mqtt-Server-FSharp-3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Building an MQTT server in F# - Part 3
        
      </div>
    </a>
  
  
    <a href="/2020/11/22/Mqtt-Server-FSharp-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Building an MQTT server in F# - Part 1</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/NET-Core/" style="font-size: 17.78px;">.NET Core</a> <a href="/tags/Accord-NET/" style="font-size: 15.56px;">Accord.NET</a> <a href="/tags/Analytics/" style="font-size: 14.44px;">Analytics</a> <a href="/tags/Audio/" style="font-size: 10px;">Audio</a> <a href="/tags/Benchmarking/" style="font-size: 10px;">Benchmarking</a> <a href="/tags/Chiron/" style="font-size: 10px;">Chiron</a> <a href="/tags/Classification/" style="font-size: 11.11px;">Classification</a> <a href="/tags/Cognitive-Services/" style="font-size: 11.11px;">Cognitive Services</a> <a href="/tags/Compiler/" style="font-size: 13.33px;">Compiler</a> <a href="/tags/Computer-Vision/" style="font-size: 11.11px;">Computer Vision</a> <a href="/tags/Cordova/" style="font-size: 10px;">Cordova</a> <a href="/tags/DTW/" style="font-size: 14.44px;">DTW</a> <a href="/tags/Data/" style="font-size: 17.78px;">Data</a> <a href="/tags/Database/" style="font-size: 13.33px;">Database</a> <a href="/tags/Decision-Trees/" style="font-size: 11.11px;">Decision Trees</a> <a href="/tags/Deedle/" style="font-size: 10px;">Deedle</a> <a href="/tags/Delegate/" style="font-size: 10px;">Delegate</a> <a href="/tags/Detection/" style="font-size: 10px;">Detection</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Dynamic-Time-Warping/" style="font-size: 13.33px;">Dynamic Time Warping</a> <a href="/tags/EEG/" style="font-size: 10px;">EEG</a> <a href="/tags/Edges/" style="font-size: 10px;">Edges</a> <a href="/tags/Education/" style="font-size: 10px;">Education</a> <a href="/tags/Elmish/" style="font-size: 10px;">Elmish</a> <a href="/tags/EmguCV/" style="font-size: 10px;">EmguCV</a> <a href="/tags/Entropy/" style="font-size: 10px;">Entropy</a> <a href="/tags/F/" style="font-size: 20px;">F#</a> <a href="/tags/FParsec/" style="font-size: 12.22px;">FParsec</a> <a href="/tags/FSAdvent/" style="font-size: 10px;">FSAdvent</a> <a href="/tags/FSharp/" style="font-size: 20px;">FSharp</a> <a href="/tags/Fable/" style="font-size: 10px;">Fable</a> <a href="/tags/Faces/" style="font-size: 11.11px;">Faces</a> <a href="/tags/Filters/" style="font-size: 10px;">Filters</a> <a href="/tags/Http/" style="font-size: 11.11px;">Http</a> <a href="/tags/Images/" style="font-size: 12.22px;">Images</a> <a href="/tags/Ionide/" style="font-size: 10px;">Ionide</a> <a href="/tags/Kaggle/" style="font-size: 12.22px;">Kaggle</a> <a href="/tags/Keyboard/" style="font-size: 13.33px;">Keyboard</a> <a href="/tags/Legos/" style="font-size: 11.11px;">Legos</a> <a href="/tags/Logging/" style="font-size: 10px;">Logging</a> <a href="/tags/MLNet/" style="font-size: 16.67px;">MLNet</a> <a href="/tags/MSIL/" style="font-size: 12.22px;">MSIL</a> <a href="/tags/Machine-Learning/" style="font-size: 18.89px;">Machine Learning</a> <a href="/tags/MathNet/" style="font-size: 10px;">MathNet</a> <a href="/tags/Messaging/" style="font-size: 10px;">Messaging</a> <a href="/tags/Mobile/" style="font-size: 10px;">Mobile</a> <a href="/tags/Mono/" style="font-size: 10px;">Mono</a> <a href="/tags/Morse-Code/" style="font-size: 10px;">Morse Code</a> <a href="/tags/Mqtt/" style="font-size: 12.22px;">Mqtt</a> <a href="/tags/Nix/" style="font-size: 10px;">Nix</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/Parsing/" style="font-size: 12.22px;">Parsing</a> <a href="/tags/Performance/" style="font-size: 11.11px;">Performance</a> <a href="/tags/Presentations/" style="font-size: 10px;">Presentations</a> <a href="/tags/Propagator/" style="font-size: 10px;">Propagator</a> <a href="/tags/Racket/" style="font-size: 10px;">Racket</a> <a href="/tags/Regression/" style="font-size: 10px;">Regression</a> <a href="/tags/Rekognition/" style="font-size: 10px;">Rekognition</a> <a href="/tags/Robotics/" style="font-size: 10px;">Robotics</a> <a href="/tags/Rust/" style="font-size: 10px;">Rust</a> <a href="/tags/STEM/" style="font-size: 11.11px;">STEM</a> <a href="/tags/Scoring/" style="font-size: 10px;">Scoring</a> <a href="/tags/Search/" style="font-size: 11.11px;">Search</a> <a href="/tags/Serialization/" style="font-size: 10px;">Serialization</a> <a href="/tags/SignalR/" style="font-size: 10px;">SignalR</a> <a href="/tags/Signals/" style="font-size: 12.22px;">Signals</a> <a href="/tags/Similarity/" style="font-size: 11.11px;">Similarity</a> <a href="/tags/Sound/" style="font-size: 10px;">Sound</a> <a href="/tags/Statistics/" style="font-size: 13.33px;">Statistics</a> <a href="/tags/Text/" style="font-size: 14.44px;">Text</a> <a href="/tags/Timeseries/" style="font-size: 10px;">Timeseries</a> <a href="/tags/Tips/" style="font-size: 12.22px;">Tips</a> <a href="/tags/Translation/" style="font-size: 10px;">Translation</a> <a href="/tags/Types/" style="font-size: 10px;">Types</a> <a href="/tags/VS-Code/" style="font-size: 10px;">VS Code</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Webapi/" style="font-size: 11.11px;">Webapi</a> <a href="/tags/admin/" style="font-size: 11.11px;">admin</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/11/Discriminated-Unions-and-Dapper/">Discriminated Unions and Dapper</a>
          </li>
        
          <li>
            <a href="/2021/11/27/Data-in-Motion-Precipitation/">Data in Motion - Precipitation Map</a>
          </li>
        
          <li>
            <a href="/2021/11/21/F-RocksDB/">Leveraging RocksDB with F#</a>
          </li>
        
          <li>
            <a href="/2021/08/07/F-String-Search/">Examining Boyer-Moore String Search with F#</a>
          </li>
        
          <li>
            <a href="/2021/07/28/Data-in-Motion-Drought/">Data in Motion - Drought Map</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 codesuji.com<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>