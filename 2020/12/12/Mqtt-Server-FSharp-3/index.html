<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Building an MQTT server in F# - Part 3 | codesuji</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Today I continue the MQTT server series by expanding capabilities to include Publish and Subscribe packets.  This will build upon the previous F#-based server foundation.">
<meta name="keywords" content="F#,FSharp,Mqtt">
<meta property="og:type" content="article">
<meta property="og:title" content="Building an MQTT server in F# - Part 3">
<meta property="og:url" content="http://codesuji.com/2020/12/12/Mqtt-Server-FSharp-3/index.html">
<meta property="og:site_name" content="codesuji">
<meta property="og:description" content="Today I continue the MQTT server series by expanding capabilities to include Publish and Subscribe packets.  This will build upon the previous F#-based server foundation.">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-12-14T02:54:28.323Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Building an MQTT server in F# - Part 3">
<meta name="twitter:description" content="Today I continue the MQTT server series by expanding capabilities to include Publish and Subscribe packets.  This will build upon the previous F#-based server foundation.">
  
    <link rel="alternate" href="/atom.xml" title="codesuji" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89982547-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">codesuji</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://codesuji.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Mqtt-Server-FSharp-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/12/Mqtt-Server-FSharp-3/" class="article-date">
  <time datetime="2020-12-13T02:41:09.000Z" itemprop="datePublished">2020-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Building an MQTT server in F# - Part 3
    </h1>
  

 		<span class="post-count">Read Time: 21 minutes</span>
 	  </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Today I continue the MQTT server series by expanding capabilities to include Publish and Subscribe packets.  This will build upon the previous <a href="https://fsharp.org" target="_blank" rel="noopener">F#</a>-based server foundation.</p>
<a id="more"></a>
<p>Looking back at the series, I previously built <a href="/2020/11/22/Mqtt-Server-FSharp-1/">basic networking</a> and <a href="/2020/11/29/Mqtt-Server-FSharp-2/">Connect</a> functionality into an MQTT server.  Just being able to perform a connection handshake is nice, but not real useful.  This means it is time to take the next step to support core MQTT functionality, namely the ability to subscribe to topics and publish messages.  As always, it is time to turn to the <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">MQTT Spec</a>.  Once connected, a client is permitted to perform several actions.  The two I’m interested in today are subscribe to topics, and publish messages. An MQTT publish message consists of two parts, a topic and a message.  The topic is how different types of messages are grouped and filtered through the system.  A system may have topics like ‘/lights/status’ or ‘/weather-station/1/temperature’.  The messages can be in any format, but processed through MQTT as bytes.  It is up to the MQTT user to define the format of topics and messages.  One or more clients subscribe to particular topics.  Additionally, clients publish messages, with an attached topic.  The MQTT server then forwards messages onto clients based on their particular subscriptions.  It is a basic pub/sub model, the important note here is that subscriptions are handled at a topic level.</p>
<p>There are a couple things I need to handle: parsing new MQTT packets, then processing those packets.  But first I need to define the types.  F# again supports this process well, as types drive everything.  Since my immediate focus is on publishing packets.  I need to be able to handle a Publish packet. I also need to be able build a PubAck packet to send back to the publishing client.  The server also needs to be able to send a Publish packet to other clients.  These types are modeled from the spec, so it is pretty direct to put these together.  Since the server will be sending messages out, I need to support serialization of these types as well.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Publish packet - Fixed header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">FixedPublishHeader</span> </span>=</span><br><span class="line">  &#123; PacketType: PacketType</span><br><span class="line">    Dup: bool</span><br><span class="line">    Qos: byte</span><br><span class="line">    Retain: bool</span><br><span class="line">    RemainingLength: int</span><br><span class="line">    Size: int</span><br><span class="line">  &#125; <span class="keyword">with</span></span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    <span class="keyword">let</span> flags =</span><br><span class="line">      (<span class="keyword">if</span> __.Dup <span class="keyword">then</span> byte <span class="number">0</span>b100 <span class="keyword">else</span> byte <span class="number">0</span>b0000)</span><br><span class="line">      ||| (__.Qos &lt;&lt;&lt; <span class="number">1</span>)</span><br><span class="line">      ||| (<span class="keyword">if</span> __.Retain <span class="keyword">then</span> byte <span class="number">0</span>b0001 <span class="keyword">else</span> byte <span class="number">0</span>b0001)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> byte1 = (byte __.PacketType &lt;&lt;&lt; <span class="number">4</span>) ||| flags</span><br><span class="line">    [| [| byte1 |]</span><br><span class="line">       (encodePacketRemainingLength __.RemainingLength) |]</span><br><span class="line">    |&gt; Array.concat</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Publish packet - Variable header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">VariablePublishHeader</span> </span>=</span><br><span class="line">  &#123; Topic: string</span><br><span class="line">    PacketIdentifier: int</span><br><span class="line">    Size: int</span><br><span class="line">  &#125; <span class="keyword">with</span></span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    [| stringToSerializedBytes __.Topic</span><br><span class="line">       [| byte (__.PacketIdentifier &gt;&gt;&gt; <span class="number">8</span>)</span><br><span class="line">          byte (__.PacketIdentifier &amp;&amp;&amp; <span class="number">0xFF</span>) |] |]</span><br><span class="line">    |&gt; Array.concat</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Publish packet - Payload </span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PublishPayload</span> </span>=</span><br><span class="line">  &#123;</span><br><span class="line">    Message: byte []</span><br><span class="line">  &#125; <span class="keyword">with</span></span><br><span class="line">  <span class="keyword">member</span> __.Serialize() = __.Message</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Publish packet</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PublishPacket</span> </span>=</span><br><span class="line">  &#123; FixedHeader: FixedPublishHeader</span><br><span class="line">    VariableHeader: VariablePublishHeader</span><br><span class="line">    Payload: PublishPayload</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">interface</span> IResponsePacket <span class="keyword">with</span></span><br><span class="line">    <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">      [| __.FixedHeader.Serialize()</span><br><span class="line">         __.VariableHeader.Serialize()</span><br><span class="line">         __.Payload.Serialize() |]</span><br><span class="line">      |&gt; Array.concat</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PubAck packet - Fixed header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PubAckFixedHeader</span> </span>=</span><br><span class="line">  &#123; PacketType: PacketType</span><br><span class="line">    RemainingLength: int &#125;</span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    [| [| byte __.PacketType &lt;&lt;&lt; <span class="number">4</span> |]</span><br><span class="line">       (encodePacketRemainingLength __.RemainingLength) |]</span><br><span class="line">    |&gt; Array.concat</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PubAck packet - Variable header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PubAckVariableHeader</span> </span>=</span><br><span class="line">  &#123; PacketIdentifier: int &#125;</span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    [| byte (__.PacketIdentifier &gt;&gt;&gt; <span class="number">8</span>)</span><br><span class="line">       byte (__.PacketIdentifier &amp;&amp;&amp; <span class="number">0xFF</span>) |]</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PubAck packet</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PubAckResponsePacket</span> </span>=</span><br><span class="line">  &#123; FixedHeader: PubAckFixedHeader</span><br><span class="line">    VariableHeader: PubAckVariableHeader &#125;</span><br><span class="line">  <span class="keyword">interface</span> IResponsePacket <span class="keyword">with</span></span><br><span class="line">    <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">      [| __.FixedHeader.Serialize()</span><br><span class="line">         __.VariableHeader.Serialize() |]</span><br><span class="line">      |&gt; Array.concat</span><br></pre></td></tr></table></figure>
<p>With the types in place, it is time to dig into the parsing.  Since I’m adding a new type I need to update the main control function.  Beyond that, the fixed header is simple to parse.  In fact, most of the fixed header parsing is very similar.  The only real difference between them is the required flags per message type.  Here, I need to extract Dup, QoS, and Retain flags; simply done with some bit-shifts and ANDing.  The message’s topic is stored in the variable header, so I need to do the standard string extraction technique that I used before.  Messages also have an associated Id, also in the variable header.  The payload, or message, is just an array of bytes.  With MQTT, it is up to the clients to determine the payload encoding method.  This is nice, I’ve used this flexibility where messages are sometimes encoded UTF-8 strings, other times they are raw byte messages off of a device, or even images. </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Handle buffer parsing</span></span><br><span class="line"><span class="keyword">let</span> parseBufferSegment (buffer: ReadOnlyMemory&lt;byte&gt;) :RequestPacket option =</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">match</span> packetType <span class="keyword">with</span></span><br><span class="line">    | PacketType.Connect    -&gt; parseConnectPacket buffer'</span><br><span class="line">    | PacketType.Publish    -&gt; parsePublishPacket buffer' </span><br><span class="line">    | _ -&gt; printfn <span class="string">"ERROR: Unsupported packet type: %A"</span> packetType</span><br><span class="line">           None    </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Parse buffer for a Publish packet</span></span><br><span class="line"><span class="keyword">let</span> parsePublishPacket (buffer: ReadOnlySpan&lt;byte&gt;) :RequestPacket option =</span><br><span class="line">  <span class="keyword">let</span> position = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> (fixedHeader, position) = parsePublishFixedHeader buffer</span><br><span class="line">  <span class="keyword">let</span> (variableHeader, position) = parsePublishVariableHeader buffer fixedHeader position</span><br><span class="line">  <span class="keyword">let</span> (payload, position) = parsePublishPayload buffer fixedHeader variableHeader position</span><br><span class="line"></span><br><span class="line">  Some(RequestPacket.Publish</span><br><span class="line">    &#123; RequestPublishPacket.FixedHeader = fixedHeader</span><br><span class="line">      VariableHeader = variableHeader</span><br><span class="line">      Payload = payload &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract fixed header (Publish) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parsePublishFixedHeader (buffer: ReadOnlySpan&lt;byte&gt;) :(FixedPublishHeader * int) =</span><br><span class="line">  <span class="keyword">let</span> position = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> packetType = getPacketType buffer.[position]</span><br><span class="line">  <span class="keyword">let</span> (remainingLength, position') = getPacketRemainingLength buffer (position + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dup = buffer.[position] &amp;&amp;&amp; <span class="number">8</span>uy &lt;&gt; <span class="number">0</span>uy</span><br><span class="line">  <span class="keyword">let</span> qos = buffer.[position] &amp;&amp;&amp; <span class="number">6</span>uy &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> retain = buffer.[position] &amp;&amp;&amp; <span class="number">1</span>uy &lt;&gt; <span class="number">0</span>uy</span><br><span class="line"></span><br><span class="line">  (&#123; FixedPublishHeader.PacketType = packetType</span><br><span class="line">     Dup = dup</span><br><span class="line">     Qos = qos</span><br><span class="line">     Retain = retain</span><br><span class="line">     RemainingLength = remainingLength</span><br><span class="line">     Size = position' &#125;,</span><br><span class="line">   position')</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract variable header (Publish) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parsePublishVariableHeader (buffer: ReadOnlySpan&lt;byte&gt;)</span><br><span class="line">                               (fixedHeader: FixedPublishHeader)</span><br><span class="line">                               (position: int)</span><br><span class="line">                               : (VariablePublishHeader * int) =</span><br><span class="line">  <span class="keyword">let</span> startPosition = position</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Topic</span></span><br><span class="line">  <span class="keyword">let</span> (topic, pos) = extractString buffer position</span><br><span class="line">  <span class="keyword">let</span> position = pos</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet identifier</span></span><br><span class="line">  <span class="keyword">let</span> packetIdentifier = twoBytesToInt (buffer.Slice(position, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> position = position + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  (&#123; VariablePublishHeader.Topic = topic</span><br><span class="line">     PacketIdentifier = packetIdentifier</span><br><span class="line">     Size = position - startPosition &#125;,</span><br><span class="line">   position)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract payload (Publish) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parsePublishPayload (buffer: ReadOnlySpan&lt;byte&gt;)</span><br><span class="line">                        (fixedHeader: FixedPublishHeader)</span><br><span class="line">                        (variableHeader: VariablePublishHeader)</span><br><span class="line">                        (position: int)</span><br><span class="line">                        : (PublishPayload * int) =</span><br><span class="line">  <span class="keyword">let</span> dataLength = fixedHeader.RemainingLength - variableHeader.Size</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> data = buffer.Slice(position, dataLength).ToArray()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> position = position + dataLength</span><br><span class="line"></span><br><span class="line">  (&#123; PublishPayload.Message = data &#125;, position)</span><br></pre></td></tr></table></figure>
<p>At this point the packet is parsed, and needs to be processed.  Here a couple things need to happen.  The server needs to send a PubAck packet back to the publishing client.  It also needs to interrogate subscriptions and forward the message onto the appropriate clients.  Additionally, the server needs to retain messages for future publishing, if the message is flagged as such.  The first step in all of this is construction of the appropriate packets.  Once done, they are passed into the state processor, where the filtering and sending are done.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Process an mqtt request packet</span></span><br><span class="line"><span class="keyword">let</span> processPacket (state: StateManager) (context: ConnectionContext) (packet: RequestPacket option) =</span><br><span class="line">  <span class="keyword">match</span> packet <span class="keyword">with</span></span><br><span class="line">  | Some(RequestPacket.Connect (p))    -&gt; processConnect state context p</span><br><span class="line">  | Some(RequestPacket.Publish (p))    -&gt; processPublish state context p</span><br><span class="line">  | Some(RequestPacket.Disconnect (p)) -&gt; processDisconnect state context</span><br><span class="line">  | None -&gt; </span><br><span class="line">      printfn <span class="string">"ERROR: Invalid packet data. Disconnecting..."</span></span><br><span class="line">      processDisconnect state context</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Process a Publish packet</span></span><br><span class="line"><span class="keyword">let</span> processPublish (state: StateManager) (context: ConnectionContext) (packet: PublishPacket) :ProcessResult option =</span><br><span class="line">  <span class="comment">// Build pubaack packet</span></span><br><span class="line">  <span class="keyword">let</span> ackVariableHeader = &#123; PubAckVariableHeader.PacketIdentifier = packet.VariableHeader.PacketIdentifier &#125;</span><br><span class="line">  <span class="keyword">let</span> variableHeader' = ackVariableHeader.Serialize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ackFixedHeader =</span><br><span class="line">    &#123; PubAckFixedHeader.PacketType = PacketType.SubAck</span><br><span class="line">      RemainingLength = variableHeader'.Length &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pubAckPacket =</span><br><span class="line">    &#123; PubAckResponsePacket.FixedHeader = ackFixedHeader</span><br><span class="line">      VariableHeader = ackVariableHeader &#125;</span><br><span class="line">  <span class="keyword">let</span> ackMessage = serializeResponsePacket pubAckPacket</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Build a publish packet for subscribed clients</span></span><br><span class="line">  <span class="keyword">let</span> pubVariableHeader =</span><br><span class="line">    &#123; VariablePublishHeader.Topic = packet.VariableHeader.Topic</span><br><span class="line">      PacketIdentifier = packet.VariableHeader.PacketIdentifier</span><br><span class="line">      Size = <span class="number">0</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> pubVariableHeader' = pubVariableHeader.Serialize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pubPayload = &#123; PublishPayload.Message = packet.Payload.Message &#125;</span><br><span class="line">  <span class="keyword">let</span> pubPayload' = pubPayload.Serialize()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> remainingLength = (pubVariableHeader'.Length + pubPayload'.Length)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pubFixedHeader =</span><br><span class="line">    &#123; FixedPublishHeader.PacketType = PacketType.Publish</span><br><span class="line">      Dup = packet.FixedHeader.Dup</span><br><span class="line">      Qos = packet.FixedHeader.Qos</span><br><span class="line">      Retain = packet.FixedHeader.Retain</span><br><span class="line">      RemainingLength = remainingLength</span><br><span class="line">      Size = <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pubMessage =</span><br><span class="line">    &#123; PublishPacket.FixedHeader = pubFixedHeader</span><br><span class="line">      VariableHeader = pubVariableHeader</span><br><span class="line">      Payload = pubPayload &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pubMessage = serializeResponsePacket pubMessage</span><br><span class="line"></span><br><span class="line">  state.Post(StateMessage.Publish(context, pubMessage, packet.VariableHeader.Topic, ackMessage, packet.FixedHeader.Retain))</span><br><span class="line"></span><br><span class="line">  None</span><br></pre></td></tr></table></figure>
<p>Just like previous posts, the state manager controls message sending and tracking state.  First it sends a PubAck back to the client.  After that it needs to do subscription filtering and sends.  The filtering happens based on text matching as defined in the spec.  It supports exact string matches as well as wildcarding used the <code>#</code> and <code>*</code> characters.  Once the destination clients are determined it is a matter of sending.  This can be done in parallel, which can be easily accomplished using <code>Async.Parallel</code>.  I realize this isn’t truly unique of F#, but I love how easy the semantics are to parallelize types of workloads.  This is definitely a win in the F# column.  To ensure proper QoS, it needs to track messages sent to clients.  This way the server can resend lost messages if appropriate, etc.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Interface to state manager</span></span><br><span class="line"><span class="keyword">let</span> stateManager () =</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">match</span> msg <span class="keyword">with</span></span><br><span class="line">  | Connect (connection, message) -&gt; stateConnect s connection message</span><br><span class="line">  | Publish (connection, message, topic, ack, retain) -&gt; statePublish s connection message topic ack retain</span><br><span class="line">  | Disconnect (connection) -&gt; stateDisconnect s connection</span><br><span class="line">  ... </span><br><span class="line"></span><br><span class="line"><span class="comment">/// Handle message publishing</span></span><br><span class="line"><span class="keyword">let</span> statePublish (state: MqttState)</span><br><span class="line">                 (connection: ConnectionContext)</span><br><span class="line">                 (message: byte [])</span><br><span class="line">                 (topic: string)</span><br><span class="line">                 (ackMessage: byte [])</span><br><span class="line">                 (retain: bool) =</span><br><span class="line">  async &#123;</span><br><span class="line">    <span class="comment">// Write puback to client</span></span><br><span class="line">    <span class="keyword">let!</span> success = writeMessage connection ackMessage</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process filters and send to other clients</span></span><br><span class="line">    <span class="keyword">let</span> matchingFilters =</span><br><span class="line">      state.ConnectedClients</span><br><span class="line">      |&gt; Map.toArray</span><br><span class="line">      |&gt; Array.collect (<span class="keyword">fun</span> (k, v) -&gt; v.Subscriptions |&gt; Array.map (<span class="keyword">fun</span> x -&gt; (k, x)))</span><br><span class="line">      |&gt; Array.filter (<span class="keyword">fun</span> (k, v) -&gt; isSubscriptionMatch topic v.Topic)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> results =</span><br><span class="line">      matchingFilters</span><br><span class="line">      |&gt; Array.map (<span class="keyword">fun</span> (k, v) -&gt; (k, v, state.ConnectedClients.TryFind(k)))</span><br><span class="line">      |&gt; Array.filter (<span class="keyword">fun</span> (_, _, x) -&gt; x.IsSome)</span><br><span class="line">      |&gt; Array.map (<span class="keyword">fun</span> (k, v, c) -&gt; writeMessage c.Value.Context message)</span><br><span class="line">      |&gt; Async.Parallel</span><br><span class="line">      |&gt; Async.RunSynchronously</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> clients =</span><br><span class="line">      matchingFilters</span><br><span class="line">      |&gt; Array.map (<span class="keyword">fun</span> (k, v) -&gt; &#123; ActiveMessageClient.ClientId = k; Qos = v.Qos &#125;)</span><br><span class="line">      |&gt; Array.toList</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> activeMessage =</span><br><span class="line">      &#123; ActiveMessage.Message = message</span><br><span class="line">        Retained = retain</span><br><span class="line">        Clients = clients &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> state' = &#123; state <span class="keyword">with</span> ActiveMessages = activeMessage :: state.ActiveMessages &#125;</span><br><span class="line">    <span class="keyword">return</span> state'</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>That wasn’t so bad.  Now the server can handle Publish messages.  This means I need to handle the other side of the equation, subscriptions.  Publishing doesn’t mean much if no one is listening.  For this interaction, the server needs to be able to handle a Subscribe message as well as return a SubAck message to the client.  Like before, I start with the types.  Again, I need to handle serialization so I can send these messages to clients.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Subscribe packet - Fixed header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">FixedSubscribeHeader</span> </span>=</span><br><span class="line">  &#123; PacketType: PacketType</span><br><span class="line">    RemainingLength: int</span><br><span class="line">    Size: int &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Subscribe packet - Variable header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">VariableSubscribeHeader</span> </span>= &#123; PacketIdentifier: int; Size: int &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">TopicFilter</span> </span>= &#123; Topic: string; Qos: byte &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">SubscribePayload</span> </span>= &#123; Filters: TopicFilter [] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Subscribe packet</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">SubscribePacket</span> </span>=</span><br><span class="line">  &#123; FixedHeader: FixedSubscribeHeader</span><br><span class="line">    VariableHeader: VariableSubscribeHeader</span><br><span class="line">    Payload: SubscribePayload &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubAck packet - Fixed header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">SubAckFixedHeader</span> </span>=</span><br><span class="line">  &#123; PacketType: PacketType</span><br><span class="line">    RemainingLength: int &#125;</span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    [| [| byte __.PacketType &lt;&lt;&lt; <span class="number">4</span> |]</span><br><span class="line">       (encodePacketRemainingLength __.RemainingLength) |]</span><br><span class="line">    |&gt; Array.concat</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubAck packet - Variable header</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">SubAckVariableHeader</span> </span>=</span><br><span class="line">  &#123; PacketIdentifier: int &#125;</span><br><span class="line">  <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">    [| byte (__.PacketIdentifier &gt;&gt;&gt; <span class="number">8</span>)</span><br><span class="line">       byte (__.PacketIdentifier &amp;&amp;&amp; <span class="number">0xFF</span>) |]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubAck packet - Payload</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">SubAckPayload</span> </span>=</span><br><span class="line">  &#123; Qoses: byte [] &#125;</span><br><span class="line">  <span class="keyword">member</span> __.Serialize() = __.Qoses</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubAck packet</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">SubAckPacket</span> </span>=</span><br><span class="line">  &#123; FixedHeader: SubAckFixedHeader</span><br><span class="line">    VariableHeader: SubAckVariableHeader</span><br><span class="line">    Payload: SubAckPayload &#125;</span><br><span class="line">  <span class="keyword">interface</span> IResponsePacket <span class="keyword">with</span></span><br><span class="line">    <span class="keyword">member</span> __.Serialize() =</span><br><span class="line">      [| __.FixedHeader.Serialize()</span><br><span class="line">         __.VariableHeader.Serialize()</span><br><span class="line">         __.Payload.Serialize() |]</span><br><span class="line">      |&gt; Array.concat</span><br></pre></td></tr></table></figure>
<p>This almost feels repetitive, but now parse the incoming packets.  Like the publish, there is a packet Id in the variable header for tracking.  A subscription message can contain multiple subscriptions.  As a result, the message is a list of topics along with their desired QoS.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Extract a packet from the buffer</span></span><br><span class="line"><span class="keyword">let</span> parseBufferSegment (buffer: ReadOnlyMemory&lt;byte&gt;) :RequestPacket option =</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">match</span> packetType <span class="keyword">with</span></span><br><span class="line">    | PacketType.Connect    -&gt; parseConnectPacket buffer'</span><br><span class="line">    | PacketType.Publish    -&gt; parsePublishPacket buffer' </span><br><span class="line">    | PacketType.Subscribe  -&gt; parseSubscribePacket buffer'</span><br><span class="line">    | _ -&gt; printfn <span class="string">"ERROR: Unsupported packet type: %A"</span> packetType</span><br><span class="line">           None    </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Parse buffer for a Subscribe packet</span></span><br><span class="line"><span class="keyword">let</span> parseSubscribePacket (buffer: ReadOnlySpan&lt;byte&gt;) :RequestPacket option =</span><br><span class="line">  <span class="keyword">let</span> position = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> (fixedHeader, position) = parseSubscribeFixedHeader buffer</span><br><span class="line">  <span class="keyword">let</span> (variableHeader, position) = parseSubscribeVariableHeader buffer fixedHeader position</span><br><span class="line">  <span class="keyword">let</span> (payload, position) = parseSubscribePayload buffer fixedHeader variableHeader position</span><br><span class="line"></span><br><span class="line">  Some(RequestPacket.Subscribe</span><br><span class="line">    &#123; SubscribePacket.FixedHeader = fixedHeader</span><br><span class="line">      VariableHeader = variableHeader</span><br><span class="line">      Payload = payload &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract fixed header (Subscribe) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parseSubscribeFixedHeader (buffer: ReadOnlySpan&lt;byte&gt;) :(FixedSubscribeHeader * int) =</span><br><span class="line">  <span class="keyword">let</span> position = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> packetType = getPacketType buffer.[position]</span><br><span class="line">  <span class="keyword">let</span> (remainingLength, position') = getPacketRemainingLength buffer (position + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  (&#123; FixedSubscribeHeader.PacketType = packetType</span><br><span class="line">     RemainingLength = remainingLength</span><br><span class="line">     Size = position' &#125;,</span><br><span class="line">   position')</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract variable header (Subscribe) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parseSubscribeVariableHeader (buffer: ReadOnlySpan&lt;byte&gt;)</span><br><span class="line">                                 (fixedHeader: FixedSubscribeHeader)</span><br><span class="line">                                 (position: int)</span><br><span class="line">                                 : (VariableSubscribeHeader * int) =</span><br><span class="line">  <span class="keyword">let</span> startPosition = position</span><br><span class="line"></span><br><span class="line">  <span class="comment">// packet identifier</span></span><br><span class="line">  <span class="keyword">let</span> packetIdentifier = twoBytesToInt (buffer.Slice(position, <span class="number">2</span>))</span><br><span class="line">  <span class="keyword">let</span> position = position + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  (&#123; VariableSubscribeHeader.PacketIdentifier = packetIdentifier</span><br><span class="line">     Size = position - startPosition &#125;,</span><br><span class="line">   position)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Extract payload (Subscribe) from buffer</span></span><br><span class="line"><span class="keyword">let</span> parseSubscribePayload (buffer: ReadOnlySpan&lt;byte&gt;)</span><br><span class="line">                          (fixedHeader: FixedSubscribeHeader)</span><br><span class="line">                          (variableHeader: VariableSubscribeHeader)</span><br><span class="line">                          (start: int)</span><br><span class="line">                          : (SubscribePayload * int) =</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> position = start</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> filters = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> payloadSize = fixedHeader.RemainingLength - variableHeader.Size</span><br><span class="line">  <span class="keyword">while</span> position - start &lt; payloadSize <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> (data, pos) = extractString buffer position</span><br><span class="line">    <span class="keyword">let</span> qos = buffer.[pos]</span><br><span class="line">    position &lt;- pos + <span class="number">1</span></span><br><span class="line">    filters &lt;- &#123; TopicFilter.Topic = data; Qos = qos &#125; :: filters</span><br><span class="line"></span><br><span class="line">  (&#123; SubscribePayload.Filters = filters |&gt; List.toArray &#125;, position)</span><br></pre></td></tr></table></figure>
<p>Once parsed, we’re back to processing.  The match expression is growing as I add functionality.  In this case the server needs to send a SubAck back to the client.  Then it can pass the subscriptions onto the stateManager for tracking.  This is a simple task of just updating the specified client’s list of subscriptions.  If you remember from above this is how the Publish determines who sees the messages.  When broken down into it’s components, there isn’t much interesting here to see, but again, F# makes this process clean.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> processPacket (state: StateManager) (context: ConnectionContext) (packet: RequestPacket option) =</span><br><span class="line">  <span class="keyword">match</span> packet <span class="keyword">with</span></span><br><span class="line">  | Some(RequestPacket.Connect (p))    -&gt; processConnect state context p</span><br><span class="line">  | Some(RequestPacket.Publish (p))    -&gt; processPublish state context p</span><br><span class="line">  | Some(RequestPacket.PubComp (p))    -&gt; processPubComp state context p</span><br><span class="line">  | Some(RequestPacket.Subscribe (p))  -&gt; processSubscribe state context p</span><br><span class="line">  | Some(RequestPacket.Disconnect (p)) -&gt; processDisconnect state context</span><br><span class="line">  | None -&gt; </span><br><span class="line">      printfn <span class="string">"ERROR: Invalid packet data. Disconnecting..."</span></span><br><span class="line">      processDisconnect state context</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Process a Subscribe packet</span></span><br><span class="line"><span class="keyword">let</span> processSubscribe (state: StateManager)</span><br><span class="line">                     (context: ConnectionContext)</span><br><span class="line">                     (packet: SubscribePacket)</span><br><span class="line">                     : ProcessResult option =</span><br><span class="line">  <span class="keyword">let</span> variableHeader = &#123; SubAckVariableHeader.PacketIdentifier = packet.VariableHeader.PacketIdentifier &#125;</span><br><span class="line">  <span class="keyword">let</span> variableHeader' = variableHeader.Serialize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ackPayload =</span><br><span class="line">    &#123; SubAckPayload.Qoses =</span><br><span class="line">        packet.Payload.Filters</span><br><span class="line">        |&gt; Array.map (<span class="keyword">fun</span> x -&gt; x.Qos) &#125;</span><br><span class="line">  <span class="keyword">let</span> payload' = ackPayload.Serialize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> fixedHeader =</span><br><span class="line">    &#123; SubAckFixedHeader.PacketType = PacketType.SubAck</span><br><span class="line">      RemainingLength = (variableHeader'.Length + payload'.Length) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> subAckPacket =</span><br><span class="line">    &#123; SubAckPacket.FixedHeader = fixedHeader</span><br><span class="line">      VariableHeader = variableHeader</span><br><span class="line">      Payload = ackPayload &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> message = serializeResponsePacket subAckPacket</span><br><span class="line">  state.Post(StateMessage.Subscribe(context, message, packet.Payload.Filters))</span><br><span class="line"></span><br><span class="line">  None</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Interface to state manager</span></span><br><span class="line"><span class="keyword">let</span> stateManager () =</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">match</span> msg <span class="keyword">with</span></span><br><span class="line">  | Connect (connection, message) -&gt; stateConnect s connection message</span><br><span class="line">  | Publish (connection, message, topic, ack, retain) -&gt; statePublish s connection message topic ack retain</span><br><span class="line">  | Subscribe (connection, message, subscriptions) -&gt; stateSubscribe s connection message subscriptions</span><br><span class="line">  | Disconnect (connection) -&gt; stateDisconnect s connection</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Handle client subscription to topic(s)</span></span><br><span class="line"><span class="keyword">let</span> stateSubscribe (state: MqttState) (connection: ConnectionContext) (message: byte []) (subscriptions: TopicFilter []) =</span><br><span class="line">  async &#123;</span><br><span class="line">    <span class="keyword">let!</span> success = writeMessage connection message</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add subscription filter</span></span><br><span class="line">    <span class="keyword">let</span> client = Map.tryFind connection.ConnectionId state.ConnectedClients</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> state' =</span><br><span class="line">      <span class="keyword">match</span> client <span class="keyword">with</span></span><br><span class="line">      | Some (c) -&gt;</span><br><span class="line">          <span class="keyword">let</span> subscriptions' = Array.concat [| subscriptions; c.Subscriptions |]</span><br><span class="line">          <span class="keyword">let</span> client' = &#123; c <span class="keyword">with</span> Subscriptions = subscriptions' &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> clients' =</span><br><span class="line">            state.ConnectedClients</span><br><span class="line">            |&gt; Map.remove connection.ConnectionId</span><br><span class="line">            |&gt; Map.add connection.ConnectionId client'</span><br><span class="line"></span><br><span class="line">          &#123; state <span class="keyword">with</span> ConnectedClients = clients' &#125;</span><br><span class="line">      | None -&gt; state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state'</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Now that all the parts in place, it’s time to see it in action.  I fire up the new server and run my trusty client script.  The goal here is to connect, subscribe to a topic, publish to that topic, and see a result on the client side.  Below you can see that is exactly what happens.  On the server side you can track the messages as they arrive.  The state debugging shows connected clients as well as their subscriptions.  I also note what messages the server is sending back to the client.  Once the client has sent it’s message it disconnects, thus causing the server to remove it from it’s state tracking.  On the client side we get confirmation of this process, after publishing a message I can see the result come back through the appropriate channels.  Not shown here, but I did several tests with multiple clients, topics, and subscriptions.  All appears to work as intended.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Server</span><br><span class="line">$ dotnet run</span><br><span class="line">Content root path: /home/codesuji/projects/mqtt-server/src</span><br><span class="line">Now listening on: http://localhost:1883</span><br><span class="line">Application started. Press Ctrl+C to shut down.</span><br><span class="line">Packet (60): Length:  60 Data: 10 3A 00 04 4D 51 54 54 04 C6 00 64 00 0F 6D 71 74 74 6A 73 5F 62 39 33 35 37 30 35 65 00 06 69 2D 64 69 65 64 00 07 63 6C 69 65 6E 74 41 00 05 75 73 65 72 31 00 05 70 61 73 73 31</span><br><span class="line">PacketType: Connect</span><br><span class="line">Sending: [|32uy; 2uy; 0uy; 0uy|]</span><br><span class="line">State:</span><br><span class="line">  Clients:</span><br><span class="line">    0HM4UKIREI3HR Subscriptions: </span><br><span class="line">  Messages:</span><br><span class="line">Packet (16): Length:  16 Data: 82 0E A7 0F 00 09 74 6F 70 69 63 2D 66 6F 6F 00</span><br><span class="line">PacketType: Subscribe</span><br><span class="line">Sending: [|144uy; 3uy; 167uy; 15uy; 0uy|]</span><br><span class="line">State:</span><br><span class="line">  Clients:</span><br><span class="line">    0HM4UKIREI3HR Subscriptions: topic-foo</span><br><span class="line">  Messages:</span><br><span class="line">Packet (29): Length:  29 Data: 30 1B 00 09 74 6F 70 69 63 2D 66 6F 6F 4D 79 20 66 69 72 73 74 20 6D 65 73 73 61 67 65</span><br><span class="line">PacketType: Publish</span><br><span class="line">Sending: [|144uy; 2uy; 77uy; 121uy|]</span><br><span class="line">*************************************************************</span><br><span class="line">matches: [|(&quot;0HM4UKIREI3HR&quot;, &#123; Topic = &quot;topic-foo&quot; Qos = 0uy &#125;)|]</span><br><span class="line">Sending: [|49uy; 27uy; 0uy; 9uy; 116uy; 111uy; 112uy; 105uy; 99uy; 45uy; 102uy; 111uy;</span><br><span class="line">  111uy; 77uy; 121uy; 32uy; 102uy; 105uy; 114uy; 115uy; 116uy; 32uy; 109uy;</span><br><span class="line">  101uy; 115uy; 115uy; 97uy; 103uy; 101uy|]</span><br><span class="line">Packet (2): Length:   2 Data: E0 00</span><br><span class="line">PacketType: Disconnect</span><br><span class="line">State:</span><br><span class="line">  Clients:</span><br><span class="line">  Messages:</span><br><span class="line">State:</span><br><span class="line">  Clients:</span><br><span class="line">  Messages:</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Client</span><br><span class="line">$ node mqtt-client.js </span><br><span class="line">Connected Packet &#123;</span><br><span class="line">  cmd: &apos;connack&apos;,</span><br><span class="line">  retain: false,</span><br><span class="line">  qos: 0,</span><br><span class="line">  dup: false,</span><br><span class="line">  length: 2,</span><br><span class="line">  topic: null,</span><br><span class="line">  payload: null,</span><br><span class="line">  sessionPresent: false,</span><br><span class="line">  returnCode: 0</span><br><span class="line">&#125;</span><br><span class="line">Subscribed.</span><br><span class="line">Sending: My first message</span><br><span class="line">Published.</span><br><span class="line">Message Received: topic-foo :: My first message</span><br><span class="line">Connection closed.</span><br></pre></td></tr></table></figure>
<p>At this point, I’ve completed the primary loop of MQTT functionality.  Clients can connect, publish, and subscribe to my MQTT server.  I’d say that’s pretty cool.  This is by no means complete, there are still many smaller supporting bits to add, but this gets it to a point where it is easy to iteratively improve.  Adding Subscribe and Publish weren’t particularly difficult once I had the underlying foundation in place, including types defining the system.  I think this is another good example of how F# can be a valuable tool when writing servers.  A solid underlying structure and a productive language can go a long way to ensure a properly functioning system.  I hope you enjoyed this little adventure and found it useful.  </p>

        <div class="related-posts-box">
        Related Posts:<ul class="related-posts"><li class="related-posts-item"><a class="related-posts-link" href="/2020/11/22/Mqtt-Server-FSharp-1/">Building an MQTT server in F# - Part 1</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2020/11/29/Mqtt-Server-FSharp-2/">Building an MQTT server in F# - Part 2</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2017/03/13/bf-compiler-part4-optimization/">BF Compiler Part 4 - Optimization</a></li></ul>        </div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://codesuji.com/2020/12/12/Mqtt-Server-FSharp-3/" data-id="clg8exog300dmw5mwnys0csjt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/F/">F#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FSharp/">FSharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mqtt/">Mqtt</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/09/F-Scripting/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          F# Scripting
        
      </div>
    </a>
  
  
    <a href="/2020/11/29/Mqtt-Server-FSharp-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Building an MQTT server in F# - Part 2</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/NET-Core/" style="font-size: 17.27px;">.NET Core</a> <a href="/tags/Accord-NET/" style="font-size: 14.55px;">Accord.NET</a> <a href="/tags/Algorithms/" style="font-size: 15.45px;">Algorithms</a> <a href="/tags/Analytics/" style="font-size: 13.64px;">Analytics</a> <a href="/tags/Audio/" style="font-size: 10px;">Audio</a> <a href="/tags/Benchmarking/" style="font-size: 10.91px;">Benchmarking</a> <a href="/tags/Chiron/" style="font-size: 10px;">Chiron</a> <a href="/tags/Classification/" style="font-size: 10.91px;">Classification</a> <a href="/tags/Cognitive-Services/" style="font-size: 10.91px;">Cognitive Services</a> <a href="/tags/Compiler/" style="font-size: 12.73px;">Compiler</a> <a href="/tags/Computer-Vision/" style="font-size: 10.91px;">Computer Vision</a> <a href="/tags/Cordova/" style="font-size: 10px;">Cordova</a> <a href="/tags/DTW/" style="font-size: 13.64px;">DTW</a> <a href="/tags/Data/" style="font-size: 18.18px;">Data</a> <a href="/tags/Database/" style="font-size: 12.73px;">Database</a> <a href="/tags/Decision-Trees/" style="font-size: 10.91px;">Decision Trees</a> <a href="/tags/Deedle/" style="font-size: 10px;">Deedle</a> <a href="/tags/Delegate/" style="font-size: 10px;">Delegate</a> <a href="/tags/Detection/" style="font-size: 10px;">Detection</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Dynamic-Time-Warping/" style="font-size: 12.73px;">Dynamic Time Warping</a> <a href="/tags/EEG/" style="font-size: 10px;">EEG</a> <a href="/tags/Edges/" style="font-size: 10px;">Edges</a> <a href="/tags/Education/" style="font-size: 10px;">Education</a> <a href="/tags/Elmish/" style="font-size: 10px;">Elmish</a> <a href="/tags/EmguCV/" style="font-size: 10px;">EmguCV</a> <a href="/tags/Entropy/" style="font-size: 10px;">Entropy</a> <a href="/tags/F/" style="font-size: 20px;">F#</a> <a href="/tags/FParsec/" style="font-size: 11.82px;">FParsec</a> <a href="/tags/FSAdvent/" style="font-size: 10px;">FSAdvent</a> <a href="/tags/FSharp/" style="font-size: 20px;">FSharp</a> <a href="/tags/Fable/" style="font-size: 10px;">Fable</a> <a href="/tags/Faces/" style="font-size: 10.91px;">Faces</a> <a href="/tags/Filters/" style="font-size: 10px;">Filters</a> <a href="/tags/Http/" style="font-size: 10.91px;">Http</a> <a href="/tags/Images/" style="font-size: 11.82px;">Images</a> <a href="/tags/Ionide/" style="font-size: 10px;">Ionide</a> <a href="/tags/Kaggle/" style="font-size: 11.82px;">Kaggle</a> <a href="/tags/Keyboard/" style="font-size: 12.73px;">Keyboard</a> <a href="/tags/Legos/" style="font-size: 10.91px;">Legos</a> <a href="/tags/Logging/" style="font-size: 10px;">Logging</a> <a href="/tags/MLNet/" style="font-size: 16.36px;">MLNet</a> <a href="/tags/MSIL/" style="font-size: 11.82px;">MSIL</a> <a href="/tags/Machine-Learning/" style="font-size: 19.09px;">Machine Learning</a> <a href="/tags/MathNet/" style="font-size: 10px;">MathNet</a> <a href="/tags/Messaging/" style="font-size: 10px;">Messaging</a> <a href="/tags/Mobile/" style="font-size: 10px;">Mobile</a> <a href="/tags/Mono/" style="font-size: 10px;">Mono</a> <a href="/tags/Morse-Code/" style="font-size: 10px;">Morse Code</a> <a href="/tags/Mqtt/" style="font-size: 11.82px;">Mqtt</a> <a href="/tags/Nix/" style="font-size: 10px;">Nix</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/Parsing/" style="font-size: 11.82px;">Parsing</a> <a href="/tags/Performance/" style="font-size: 12.73px;">Performance</a> <a href="/tags/Presentations/" style="font-size: 10px;">Presentations</a> <a href="/tags/Propagator/" style="font-size: 10px;">Propagator</a> <a href="/tags/Racket/" style="font-size: 10px;">Racket</a> <a href="/tags/Regression/" style="font-size: 10px;">Regression</a> <a href="/tags/Rekognition/" style="font-size: 10px;">Rekognition</a> <a href="/tags/Robotics/" style="font-size: 10px;">Robotics</a> <a href="/tags/Rust/" style="font-size: 10px;">Rust</a> <a href="/tags/STEM/" style="font-size: 10.91px;">STEM</a> <a href="/tags/Scoring/" style="font-size: 10px;">Scoring</a> <a href="/tags/Search/" style="font-size: 10.91px;">Search</a> <a href="/tags/Serialization/" style="font-size: 10px;">Serialization</a> <a href="/tags/SignalR/" style="font-size: 10px;">SignalR</a> <a href="/tags/Signals/" style="font-size: 12.73px;">Signals</a> <a href="/tags/Similarity/" style="font-size: 10.91px;">Similarity</a> <a href="/tags/Sound/" style="font-size: 10px;">Sound</a> <a href="/tags/Statistics/" style="font-size: 12.73px;">Statistics</a> <a href="/tags/Text/" style="font-size: 13.64px;">Text</a> <a href="/tags/Timeseries/" style="font-size: 10.91px;">Timeseries</a> <a href="/tags/Tips/" style="font-size: 12.73px;">Tips</a> <a href="/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/tags/Translation/" style="font-size: 10px;">Translation</a> <a href="/tags/Types/" style="font-size: 10px;">Types</a> <a href="/tags/VS-Code/" style="font-size: 10px;">VS Code</a> <a href="/tags/Web/" style="font-size: 10.91px;">Web</a> <a href="/tags/Webapi/" style="font-size: 10.91px;">Webapi</a> <a href="/tags/admin/" style="font-size: 10.91px;">admin</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/24/Distinct-Counting-in-F/">Estimating Distinct Element Counts with F#</a>
          </li>
        
          <li>
            <a href="/2024/05/21/F-and-Anthropic/">Harnessing the Anthropic API with F#</a>
          </li>
        
          <li>
            <a href="/2023/09/23/F-Flurl/">Using F# and Flurl</a>
          </li>
        
          <li>
            <a href="/2023/04/08/VectorSearch-F-1/">Vector Search using F#</a>
          </li>
        
          <li>
            <a href="/2023/03/07/Json-Bakeoff/">The Great Json Bake-Off</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 codesuji.com<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>