<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Estimated Shortest Path with F# | codesuji</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Calculating the shortest path between two nodes in large graphs can be a time-consuming process. One approach to solving this is to calculate an estimated path. There are many situations where the exa">
<meta name="keywords" content="F#,FSharp,Data,Algorithms,Benchmarking">
<meta property="og:type" content="article">
<meta property="og:title" content="Estimated Shortest Path with F#">
<meta property="og:url" content="http://codesuji.com/2024/11/27/Estimated-Shortest-Path-F/index.html">
<meta property="og:site_name" content="codesuji">
<meta property="og:description" content="Calculating the shortest path between two nodes in large graphs can be a time-consuming process. One approach to solving this is to calculate an estimated path. There are many situations where the exa">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://codesuji.com/images/wormhole1/graph.png">
<meta property="og:updated_time" content="2024-11-28T03:05:40.964Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Estimated Shortest Path with F#">
<meta name="twitter:description" content="Calculating the shortest path between two nodes in large graphs can be a time-consuming process. One approach to solving this is to calculate an estimated path. There are many situations where the exa">
<meta name="twitter:image" content="http://codesuji.com/images/wormhole1/graph.png">
    <link rel="stylesheet" href="css/fontawesome.css" type="text/css">
  
    <link rel="alternate" href="/atom.xml" title="codesuji" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">codesuji</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
          <a id="nav-share-link" class="nav-icon fa-solid fa-user" href="https://bsky.app/profile/codesuji.bsky.social" title="BlueSky" target="_blank"></a>
          <a id="nav-share-link" class="nav-icon fa-solid fa-user" href="https://hachyderm.io/@codesuji" title="Mastodon" target="_blank"></a>
          <a id="nav-rss-link" class="nav-icon fa-solid fa-rss" href="/atom.xml" title="RSS Feed"></a>
          <a id="nav-search-btn" class="nav-icon fa-solid fa-search" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://codesuji.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Estimated-Shortest-Path-F" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2024/11/27/Estimated-Shortest-Path-F/" class="article-date">
  <time datetime="2024-11-27T12:02:41.000Z" itemprop="datePublished">2024-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Estimated Shortest Path with F#
    </h1>
  

 		<span class="post-count">Read Time: 14 minutes</span>
 	  </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Calculating the shortest path between two nodes in large graphs can be a time-consuming process. One approach to solving this is to calculate an estimated path. There are many situations where the exact path isn’t necessary; an estimated path is good enough.  This is the case especially if the performance benefits of estimating are high enough. I’ll look at implementing the algorithm from <a href="/references/shortestpath1/2406.08624v1.pdf">A Sublinear Algorithm for Approximate Shortest Paths in Large Networks</a> in <a href="https://fsharp.org" target="_blank" rel="noopener">F#</a>. It offers a hefty performance boost at the cost of some preprocessing; well worth the time.</p>
<a id="more"></a>
<p>To set the stage, imagine a large, highly-connected graph with millions of nodes. Common examples are a social graphs and networking graphs.  What is the fastest way to find the shortest path between two nodes? One method is to use breadth first search (BFS) from the starting node, expanding its search until the target node is found. In a similar, but faster fashion, there is a BiBFS (a bidirectional search simultaneously from the source and target nodes, and stopping when the searches meet). Another option is to preprocess the graph and store an index the nodes and shortest paths. As you can imagine, indexing a large graph isn’t particularly practical.  A common solution to this is only index a portion of the nodes.  That’s what will be investigated today.</p>
<p>The paper describes, what they call the Wormhole algorithm. It is a method of dynamically selecting a core group of nodes to be indexed.  This method takes advantage of the characteristic of highly connected graphs.  As a preprocessing step, the core nodes are selected and indexed.  Once this is done searches use a modified BiBFS. A path can still be found directly from source to target.  But a path can also be found when both searches come in contact with the core group of nodes.  At this point, the search can look up the indexed result of part of the path to improved the performance, while accepting that the ultimate path will now be an estimate, not necessarily the fastest path.</p>
<p><img src="/images/wormhole1/graph.png" alt="Graph path through core nodes"></p>
<p>Before getting into the details of the algorithm, there is a bit of structure to define.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Graph</span> </span>= &#123;</span><br><span class="line">  <span class="comment">/// Nodes (in map form for fast lookup)</span></span><br><span class="line">  Nodes: Map&lt;string, bool&gt;</span><br><span class="line">  <span class="comment">/// List of a node's neighbors</span></span><br><span class="line">  AdjacencyList: Map&lt;string, string list&gt;</span><br><span class="line">  <span class="comment">/// Indexed version of nodes </span></span><br><span class="line">  Index: Dictionary&lt;string * string, string list&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emptyGraph =</span><br><span class="line">  &#123; Graph.Nodes = [] |&gt; Map.ofList</span><br><span class="line">    AdjacencyList = Map.empty&lt;string, string list&gt;</span><br><span class="line">    Index = <span class="keyword">new</span> Dictionary&lt;string * string, string list&gt;()&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rnd = System.Random()</span><br></pre></td></tr></table></figure>
<p>A bit of preparation is required. The core group of nodes must be selected and indexed. First, to select a core group of nodes a random node is selected from the graph and placed into what is called the “inner ring”. It’s neighbors are then placed in the “outer ring”.  The algorithm then processes all nodes in the outer ring in the similar way.  One difference is nodes from the outer ring are not selected randomly.  Since the goal is to leverage high connectivity, the node in the outer ring that has the most connections to nodes in the inner ring is selected. The selected node is placed in the inner ring.  Then its neighbors are added to the outer ring. This process repeats until the size of the inner ring meets the desired size.  At this point the processing is complete.  The inner and outer rings are combined into a core graph. The result is a highly connected group of core nodes to be used when performing partial path estimation. This is what will be used moving forward.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create an inner and outer ring of most connected verticies</span></span><br><span class="line"><span class="keyword">let</span> decomposeGraph (size: int) (graph: Graph) =</span><br><span class="line">  <span class="keyword">let</span> nodeKeys = graph.Nodes.Keys |&gt; Seq.toArray</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> decomposeGraph' (cin: string list) (cout: string list) =</span><br><span class="line">    <span class="keyword">if</span> cin.Length = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">      <span class="comment">// add random vertex to cin</span></span><br><span class="line">      <span class="keyword">let</span> v = nodeKeys[rnd.Next(nodeKeys.Length)]</span><br><span class="line">      <span class="keyword">let</span> (cin', cout') = addToCin cin cout graph v</span><br><span class="line">      decomposeGraph' cin' cout' </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> cin.Length &lt; size <span class="keyword">then</span></span><br><span class="line">      <span class="comment">// add v from cout with highest ties to cin</span></span><br><span class="line">      <span class="keyword">let</span> v =</span><br><span class="line">        cout</span><br><span class="line">        |&gt; List.filter (<span class="keyword">fun</span> x -&gt; not (List.contains x cin))</span><br><span class="line">        |&gt; List.map (<span class="keyword">fun</span> x -&gt;</span><br><span class="line">            <span class="keyword">if</span> graph.AdjacencyList.ContainsKey x <span class="keyword">then</span></span><br><span class="line">              <span class="keyword">let</span> c =</span><br><span class="line">                graph.AdjacencyList[x]</span><br><span class="line">                |&gt; List.filter (<span class="keyword">fun</span> y -&gt; List.contains y cin)</span><br><span class="line">                |&gt; List.length</span><br><span class="line">              (x, c)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              (x, <span class="number">0</span>))</span><br><span class="line">        |&gt; List.sortByDescending (<span class="keyword">fun</span> (x,y) -&gt; y)</span><br><span class="line">        |&gt; List.head</span><br><span class="line">        |&gt; fst</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> (cin', cout') = addToCin cin cout graph v</span><br><span class="line">      decomposeGraph' cin' cout' </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      (cin, cout)</span><br><span class="line"></span><br><span class="line">  decomposeGraph' [] []</span><br></pre></td></tr></table></figure>
<p>Next, the core graph must be indexed. The index is a mapping of every node pair combination and the shortest path between them <code>(start, target) -&gt; path</code>.  Although computationally intensive, it is a much smaller graph, making it viable. This is also where we get the performance boost. Once path finding hits the core group of nodes, a fast index lookup can be done instead of needing to calculate the shortest path on the fly.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Index a graph</span></span><br><span class="line"><span class="comment">/// Result is a (start, target) -&gt; path dictionary</span></span><br><span class="line"><span class="keyword">let</span> indexGraph (graph: Graph) (start: string) =</span><br><span class="line">  <span class="keyword">let</span> indexes = <span class="keyword">new</span> Dictionary&lt;string * string, string list&gt;()</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> Dictionary&lt;string, string list&gt;()</span><br><span class="line">  <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue&lt;string list&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> indexGraph' start =</span><br><span class="line">    <span class="keyword">if</span> queue.Count &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">      <span class="comment">// Keep processing if queue is populated</span></span><br><span class="line">      <span class="keyword">let</span> path = queue.Dequeue()</span><br><span class="line">      <span class="keyword">let</span> node = path.Head</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> not (indexes.ContainsKey((start, node))) <span class="keyword">then</span></span><br><span class="line">        indexes.Add((start, node), path |&gt; List.rev)</span><br><span class="line"></span><br><span class="line">      graph.AdjacencyList[node]</span><br><span class="line">      |&gt; List.filter (<span class="keyword">fun</span> neighbor -&gt; not (visited.ContainsKey neighbor))</span><br><span class="line">      |&gt; List.iter (<span class="keyword">fun</span> neighbor -&gt;</span><br><span class="line">          visited.Add(neighbor, (neighbor :: path))</span><br><span class="line">          queue.Enqueue (neighbor :: path))</span><br><span class="line"></span><br><span class="line">      indexGraph' start</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      indexes</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> n <span class="keyword">in</span> graph.Nodes.Keys <span class="keyword">do</span></span><br><span class="line">    visited.Clear()</span><br><span class="line">    visited.Add(start, [start])</span><br><span class="line">    queue.Clear()</span><br><span class="line">    queue.Enqueue [start]</span><br><span class="line">    indexGraph' n |&gt; ignore</span><br><span class="line"></span><br><span class="line">  indexes</span><br></pre></td></tr></table></figure>
<p>Creating the core graph along with its index looks like this. For this test I’ve selected an s of 600, which means the inner ring needs to get to a size of 600. This value is really dependent on the properties of the graph in question.  The size and connectedness of the graph will impact performance.  For a specific graph some experimentation may be required. But once determined, this process only needs to be run once.  It can then be saved and used for pathfinding later.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="number">600</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coreGraphTemp =</span><br><span class="line">  graph</span><br><span class="line">  |&gt; decomposeGraph s</span><br><span class="line">  |&gt; createCoreGraph graph</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coreIndex = indexGraph coreGraphTemp (Seq.head coreGraphTemp.Nodes.Keys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coreGraph = &#123; coreGraphTemp <span class="keyword">with</span> Index = coreIndex &#125;</span><br></pre></td></tr></table></figure>
<p>Now that the core graph has been created, the next step is to look at what searching looks like. Before I get to the BiBFS code, I have a supporting enqueue that conditionally adds a node to a queue based on whether the current search has found a path to the core graph yet.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">inline</span> enqueue (queue: Queue&lt;string list&gt;) (coreNodes: Map&lt;string, bool&gt;) (portalPath: (string list) option) (path: string list) :(string list) option =</span><br><span class="line">  <span class="keyword">let</span> node = List.head path</span><br><span class="line">  <span class="comment">// always enqueue</span></span><br><span class="line">  queue.Enqueue path</span><br><span class="line">  <span class="keyword">if</span> portalPath.IsNone <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> Map.containsKey node coreNodes <span class="keyword">then</span></span><br><span class="line">      <span class="comment">// Found portal node</span></span><br><span class="line">      Some path</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// Not a portal node, continue processing</span></span><br><span class="line">      None</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// Already found portal Path, just return it</span></span><br><span class="line">    portalPath</span><br></pre></td></tr></table></figure>
<p>At a high level, the algorithm simultaneously does two BFSes, one from the start node and one from the target node.  When the two searches meet, the shortest path is found.  But, the interesting aspect is the integration of the core graph. The algorithm keeps track of when the search touches one of the core nodes. If both searches connect, there is no change. But, if both searches hit the core before each other, then the path will traverse through the core set of nodes. This path is looked up in the index.  This is also where the performance comes from. </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// bfs with wormhole algorithm</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> wormholeBfs (graph: Graph) (start: string) (target: string) =</span><br><span class="line">  <span class="keyword">let</span> visited1 = <span class="keyword">new</span> Dictionary&lt;string, string list&gt;()</span><br><span class="line">  <span class="keyword">let</span> visited2 = <span class="keyword">new</span> Dictionary&lt;string, string list&gt;()</span><br><span class="line">  <span class="keyword">let</span> queue1 = <span class="keyword">new</span> Queue&lt;string list&gt;()</span><br><span class="line">  <span class="keyword">let</span> queue2 = <span class="keyword">new</span> Queue&lt;string list&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Init visited</span></span><br><span class="line">  visited1.Add(start, [start])</span><br><span class="line">  visited2.Add(target, [target])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> portalPath1 :(string list) option = None</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mutable</span> portalPath2 :(string list) option = None</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Init processing queues</span></span><br><span class="line">  portalPath1 &lt;- enqueue queue1 coreGraph.Nodes portalPath1 [start]</span><br><span class="line">  portalPath2 &lt;- enqueue queue2 coreGraph.Nodes portalPath2 [target]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> wormholeBfs' () =</span><br><span class="line">    <span class="keyword">if</span> portalPath1.IsSome &amp;&amp; portalPath2.IsSome <span class="keyword">then</span></span><br><span class="line">      <span class="comment">// Both ends are linked to the core graph</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> n1 = portalPath1.Value |&gt; List.head</span><br><span class="line">      <span class="keyword">let</span> n2 = portalPath2.Value |&gt; List.head</span><br><span class="line">      <span class="keyword">let</span> corePath :(string list) option =</span><br><span class="line">        <span class="keyword">if</span> coreGraph.Index.ContainsKey (n1, n2) <span class="keyword">then</span></span><br><span class="line">          Some coreGraph.Index[(n1, n2)]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          None</span><br><span class="line">      <span class="keyword">if</span> corePath.IsSome <span class="keyword">then</span></span><br><span class="line">        Some(</span><br><span class="line">          List.concat [</span><br><span class="line">            portalPath1.Value |&gt; List.tail |&gt; List.rev;</span><br><span class="line">            corePath.Value;</span><br><span class="line">            portalPath2.Value |&gt; List.tail |&gt; List.rev])</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        None</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> queue1.Count &gt; <span class="number">0</span> &amp;&amp; queue2.Count &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">      <span class="comment">// Keep processing if queues are populated</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> path1 = queue1.Dequeue()</span><br><span class="line">      <span class="keyword">let</span> node1 = path1.Head</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> path2 = queue2.Dequeue()</span><br><span class="line">      <span class="keyword">let</span> node2 = path2.Head</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> visited2.ContainsKey node1 <span class="keyword">then</span></span><br><span class="line">        <span class="comment">// Node from start path is in target visited</span></span><br><span class="line">        <span class="keyword">let</span> path1' =</span><br><span class="line">          path1</span><br><span class="line">          |&gt; List.tail</span><br><span class="line">          |&gt; List.rev</span><br><span class="line">        Some(path1' @ (visited2[node1]))</span><br><span class="line">      <span class="keyword">elif</span> visited1.ContainsKey node2 <span class="keyword">then</span></span><br><span class="line">        <span class="comment">// Node from target path is in start visited</span></span><br><span class="line">        <span class="keyword">let</span> path1' =</span><br><span class="line">          visited1[node2]</span><br><span class="line">          |&gt; List.tail</span><br><span class="line">          |&gt; List.rev</span><br><span class="line">        Some(path1' @ path2)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// Not common nodes found, add neighbors for the current nodes</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">          graph.AdjacencyList[node1]</span><br><span class="line">          |&gt; List.iter (<span class="keyword">fun</span> neighbor -&gt;</span><br><span class="line">              <span class="keyword">if</span> not (visited1.ContainsKey neighbor) <span class="keyword">then</span></span><br><span class="line">                visited1.Add(neighbor, (neighbor :: path1))</span><br><span class="line">                portalPath1 &lt;- enqueue queue1 coreGraph.Nodes portalPath1 (neighbor :: path1))</span><br><span class="line">          <span class="keyword">with</span></span><br><span class="line">        | _ -&gt; ()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">          graph.AdjacencyList[node2]</span><br><span class="line">          |&gt; List.iter (<span class="keyword">fun</span> neighbor -&gt;</span><br><span class="line">              <span class="keyword">if</span> not (visited2.ContainsKey neighbor) <span class="keyword">then</span></span><br><span class="line">                visited2.Add(neighbor, (neighbor :: path2))</span><br><span class="line">                portalPath2 &lt;- enqueue queue2 coreGraph.Nodes portalPath2 (neighbor :: path2))</span><br><span class="line">        <span class="keyword">with</span></span><br><span class="line">        | _ -&gt; ()</span><br><span class="line"></span><br><span class="line">        wormholeBfs'()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      None</span><br><span class="line"></span><br><span class="line">  wormholeBfs'()</span><br></pre></td></tr></table></figure>
<p>That’s pretty much it. There is preprocessing to provide a partial index that allows for faster search results. Then there the search uses this index.  So how do the results look? It should be noted any results are going to be highly dependent on the characteristics of graph as well as the size of the core indexed graph.  As with anything related to performance take this with a grain of salt. But the results can be pretty impressive.  Below are some sample path finding times from random nodes of a 10 million node graph. Is many cases the wormhole version is drastically faster, although it often comes at the cost of not-quite-the-shortest-path. The index can provide upwards of a 90% performance improvement, but even a nominal improvement is often seen. There is some overhead because of the extra portal node checks, so occasionally the search actually takes longer, if the index isn’t used. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BiBFS            Wormhole          Gain  Length (delta)</span><br><span class="line">00:00:00.0225713 00:00:00.0044238  80.4%  9 (8)</span><br><span class="line">00:00:00.0063691 00:00:00.0011482  82.0% 10 (4)</span><br><span class="line">00:00:00.0312000 00:00:00.0092429  70.4%  8 (8)</span><br><span class="line">00:00:00.0085600 00:00:00.0034126  60.1% 10 (5)</span><br><span class="line">00:00:00.0184681 00:00:00.0025473  86.2%  9 (7)</span><br><span class="line">00:00:00.0137133 00:00:00.0046735  65.9% 10 (6)</span><br><span class="line">00:00:00.0193507 00:00:00.0027667  85.7% 10 (6)</span><br><span class="line">00:00:00.0047823 00:00:00.0003425  92.8% 10 (4)</span><br><span class="line">00:00:00.0006894 00:00:00.0009595 -39.2%  8 (0)</span><br><span class="line">00:00:00.0422815 00:00:00.0033562  92.1% 10 (7)</span><br><span class="line">00:00:00.0077808 00:00:00.0021191  72.8% 10 (6)</span><br><span class="line">00:00:00.0008566 00:00:00.0007513  12.3%  7 (6)</span><br><span class="line">00:00:00.0148260 00:00:00.0013760  90.7% 10 (5)</span><br><span class="line">00:00:00.0103843 00:00:00.0031217  69.9%  9 (8)</span><br><span class="line">00:00:00.0081660 00:00:00.0017522  78.5% 10 (2)</span><br><span class="line">00:00:00.0045205 00:00:00.0035961  20.4% 10 (7)</span><br><span class="line">00:00:00.0343872 00:00:00.0066955  80.5% 10 (5)</span><br><span class="line">00:00:00.0080696 00:00:00.0048364  40.1%  9 (7)</span><br><span class="line">00:00:00.0075896 00:00:00.0122219 -61.0%  9 (8)</span><br><span class="line">00:00:00.0036436 00:00:00.0036039   1.1%  9 (0)</span><br></pre></td></tr></table></figure>
<p>There are a couple ways the provided code could be improved for performance an estimated path. But even a relatively naive implementation provides some nice benefits.  Hopefully you found some value in this dive into estimated shortest path finding and selective indexing.  If nothing else, it is valuable to consider that estimates can often be good enough, especially on large datasets where performance is an issue. Until next time.</p>
<p>References:</p>
<p><a href="/references/shortestpath1/2406.08624v1.pdf">A Sublinear Algorithm for Approximate Shortest Paths in Large Networks</a>  (original source: <a href="https://arxiv.org/pdf/2406.08624" target="_blank" rel="noopener">https://arxiv.org/pdf/2406.08624</a>)</p>

        <div class="related-posts-box">
        Related Posts:<ul class="related-posts"><li class="related-posts-item"><a class="related-posts-link" href="/2024/05/24/Distinct-Counting-in-F/">Estimating Distinct Element Counts with F#</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2021/08/07/F-String-Search/">Examining Boyer-Moore String Search with F#</a></li><li class="related-posts-item"><a class="related-posts-link" href="/2016/12/17/Dynamic-Time-Warping-an-F-Implementation/">Dynamic Time Warping, an F# Implementation</a></li></ul>        </div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://codesuji.com/2024/11/27/Estimated-Shortest-Path-F/" data-id="cm3u52kub0000pfmwicz0uqjj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Benchmarking/">Benchmarking</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data/">Data</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/F/">F#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FSharp/">FSharp</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/05/24/Distinct-Counting-in-F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Estimating Distinct Element Counts with F#</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/NET-Core/" style="font-size: 17px;">.NET Core</a> <a href="/tags/Accord-NET/" style="font-size: 15px;">Accord.NET</a> <a href="/tags/Algorithms/" style="font-size: 16px;">Algorithms</a> <a href="/tags/Analytics/" style="font-size: 14px;">Analytics</a> <a href="/tags/Audio/" style="font-size: 10px;">Audio</a> <a href="/tags/Benchmarking/" style="font-size: 12px;">Benchmarking</a> <a href="/tags/Chiron/" style="font-size: 10px;">Chiron</a> <a href="/tags/Classification/" style="font-size: 11px;">Classification</a> <a href="/tags/Cognitive-Services/" style="font-size: 11px;">Cognitive Services</a> <a href="/tags/Compiler/" style="font-size: 13px;">Compiler</a> <a href="/tags/Computer-Vision/" style="font-size: 11px;">Computer Vision</a> <a href="/tags/Cordova/" style="font-size: 10px;">Cordova</a> <a href="/tags/DTW/" style="font-size: 14px;">DTW</a> <a href="/tags/Data/" style="font-size: 18px;">Data</a> <a href="/tags/Database/" style="font-size: 13px;">Database</a> <a href="/tags/Decision-Trees/" style="font-size: 11px;">Decision Trees</a> <a href="/tags/Deedle/" style="font-size: 10px;">Deedle</a> <a href="/tags/Delegate/" style="font-size: 10px;">Delegate</a> <a href="/tags/Detection/" style="font-size: 10px;">Detection</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Dynamic-Time-Warping/" style="font-size: 13px;">Dynamic Time Warping</a> <a href="/tags/EEG/" style="font-size: 10px;">EEG</a> <a href="/tags/Edges/" style="font-size: 10px;">Edges</a> <a href="/tags/Education/" style="font-size: 10px;">Education</a> <a href="/tags/Elmish/" style="font-size: 10px;">Elmish</a> <a href="/tags/EmguCV/" style="font-size: 10px;">EmguCV</a> <a href="/tags/Entropy/" style="font-size: 10px;">Entropy</a> <a href="/tags/F/" style="font-size: 20px;">F#</a> <a href="/tags/FParsec/" style="font-size: 12px;">FParsec</a> <a href="/tags/FSAdvent/" style="font-size: 10px;">FSAdvent</a> <a href="/tags/FSharp/" style="font-size: 20px;">FSharp</a> <a href="/tags/Fable/" style="font-size: 10px;">Fable</a> <a href="/tags/Faces/" style="font-size: 11px;">Faces</a> <a href="/tags/Filters/" style="font-size: 10px;">Filters</a> <a href="/tags/Http/" style="font-size: 11px;">Http</a> <a href="/tags/Images/" style="font-size: 12px;">Images</a> <a href="/tags/Ionide/" style="font-size: 10px;">Ionide</a> <a href="/tags/Kaggle/" style="font-size: 12px;">Kaggle</a> <a href="/tags/Keyboard/" style="font-size: 13px;">Keyboard</a> <a href="/tags/Legos/" style="font-size: 11px;">Legos</a> <a href="/tags/Logging/" style="font-size: 10px;">Logging</a> <a href="/tags/MLNet/" style="font-size: 16px;">MLNet</a> <a href="/tags/MSIL/" style="font-size: 12px;">MSIL</a> <a href="/tags/Machine-Learning/" style="font-size: 19px;">Machine Learning</a> <a href="/tags/MathNet/" style="font-size: 10px;">MathNet</a> <a href="/tags/Messaging/" style="font-size: 10px;">Messaging</a> <a href="/tags/Mobile/" style="font-size: 10px;">Mobile</a> <a href="/tags/Mono/" style="font-size: 10px;">Mono</a> <a href="/tags/Morse-Code/" style="font-size: 10px;">Morse Code</a> <a href="/tags/Mqtt/" style="font-size: 12px;">Mqtt</a> <a href="/tags/Nix/" style="font-size: 10px;">Nix</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/Parsing/" style="font-size: 12px;">Parsing</a> <a href="/tags/Performance/" style="font-size: 13px;">Performance</a> <a href="/tags/Presentations/" style="font-size: 10px;">Presentations</a> <a href="/tags/Propagator/" style="font-size: 10px;">Propagator</a> <a href="/tags/Racket/" style="font-size: 10px;">Racket</a> <a href="/tags/Regression/" style="font-size: 10px;">Regression</a> <a href="/tags/Rekognition/" style="font-size: 10px;">Rekognition</a> <a href="/tags/Robotics/" style="font-size: 10px;">Robotics</a> <a href="/tags/Rust/" style="font-size: 10px;">Rust</a> <a href="/tags/STEM/" style="font-size: 11px;">STEM</a> <a href="/tags/Scoring/" style="font-size: 10px;">Scoring</a> <a href="/tags/Search/" style="font-size: 11px;">Search</a> <a href="/tags/Serialization/" style="font-size: 10px;">Serialization</a> <a href="/tags/SignalR/" style="font-size: 10px;">SignalR</a> <a href="/tags/Signals/" style="font-size: 13px;">Signals</a> <a href="/tags/Similarity/" style="font-size: 11px;">Similarity</a> <a href="/tags/Sound/" style="font-size: 10px;">Sound</a> <a href="/tags/Statistics/" style="font-size: 13px;">Statistics</a> <a href="/tags/Text/" style="font-size: 14px;">Text</a> <a href="/tags/Timeseries/" style="font-size: 11px;">Timeseries</a> <a href="/tags/Tips/" style="font-size: 13px;">Tips</a> <a href="/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/tags/Translation/" style="font-size: 10px;">Translation</a> <a href="/tags/Types/" style="font-size: 10px;">Types</a> <a href="/tags/VS-Code/" style="font-size: 10px;">VS Code</a> <a href="/tags/Web/" style="font-size: 11px;">Web</a> <a href="/tags/Webapi/" style="font-size: 11px;">Webapi</a> <a href="/tags/admin/" style="font-size: 11px;">admin</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/27/Estimated-Shortest-Path-F/">Estimated Shortest Path with F#</a>
          </li>
        
          <li>
            <a href="/2024/05/24/Distinct-Counting-in-F/">Estimating Distinct Element Counts with F#</a>
          </li>
        
          <li>
            <a href="/2024/05/21/F-and-Anthropic/">Harnessing the Anthropic API with F#</a>
          </li>
        
          <li>
            <a href="/2023/09/23/F-Flurl/">Using F# and Flurl</a>
          </li>
        
          <li>
            <a href="/2023/04/08/VectorSearch-F-1/">Vector Search using F#</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 codesuji.com<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>